---
title: 浏览器渲染原理
tags:
  - web前端
categories:
  - 技术日志
  - 浏览器相关
date: 2020-03-06 19:06:04
visible:
---


# 浏览器渲染原理

浏览器渲染原理是面试必考题，很不幸，我在今天之前还是对其模棱两可。结果今天面试被问到了。面试过后，我在网上找了很多相关的帖子，要不就是太简单，要不就是太复杂，把编译原理都说了一遍。直到我突然发现了谷歌的官方文档给出了详细的描述，故写下这篇博客，将这部分知识掌握。

谷歌官方文档的这篇文章是在性能优化那部分写的，所以里面穿插了很多性能优化方面的内容。

## 认识浏览器引擎

浏览器有一个`JS`引擎，也有一个渲染引擎，例如比较出名的`Webkit`，`Gecko`指的都是渲染引擎。至于`JS`引擎最著名的自然就是谷歌的`V8`引擎了。

浏览器渲染相关指的是浏览器的渲染引擎。值得注意的是，浏览器界面渲染引擎和网络操作是两个独立的线程，所以下载文件和渲染对象模型不冲突。

## 构建 DOM 和 CSSOM 树

浏览器渲染页面前需要构建`DOM`树和`CSSOM`树。这是两个独立的数据结构，`HTML`标记转换成文档对象模型 （DOM）；`CSS`标记转换成`CSS`对象模型 （CSSOM）。它们都经过如下的转换过程。

> 字节 → 字符 → 令牌 → 节点 → 对象模型。

### 构建 DOM 树

```html
<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link href="style.css" rel="stylesheet" />
    <title>Critical Path</title>
  </head>
  <body>
    <p>Hello <span>web performance</span> students!</p>
    <div><img src="awesome-photo.jpg" /></div>
  </body>
</html>
```

浏览器采用如下步骤处理上面的`HTML`页面。

![](full-process.png)

1. 转换： 浏览器从磁盘或网络读取`HTML`的原始字节，并根据文件的指定编码（例如 UTF-8）将它们转换成各个字符。

2. 令牌化： 浏览器将字符串转换成`W3C HTML5`标准规定的各种令牌，例如，`<html>`、`<body>`，以及其他尖括号内的字符串。每个令牌都具有特殊含义和一组规则。

3. 词法分析： 发出的令牌转换成定义其属性和规则的“对象”（Node）。

4. `DOM`构建： 最后，由于`HTML`标记定义不同标记之间的关系（一些标记包含在其他标记内），创建的对象链接在一个树数据结构内，此结构也会捕获原始标记中定义的父项-子项关系：*`HTML`对象是`body`对象*的父项，*`body`是`paragraph`对象*的父项，依此类推。

最终输出是页面对应的文档对象模型（DOM），浏览器对页面进行的所有进一步处理都会用到它。

![](dom-tree.png)

浏览器每次处理`HTMl`标记都会完成以上所有步骤。

### 构建 CSS 对象模型

在浏览器构建页面的`DOM`时，在文档的`<head>`标签遇到了一个`<link>`标记，该标记引用了外部的一个文件。浏览器直到会使用该资源来加载页面，当遇到这个链接时，会立刻发出对该资源的请求，一旦浏览器下载好样式文件，就开始进行解析。假设返回了以下内容。

```css
body {
  font-size: 16px;
}
p {
  font-weight: bold;
}
span {
  color: red;
}
p span {
  display: none;
}
img {
  float: right;
}
```

声明内联样式也不是不可以，但是为了实现关注点分离，便于维护等目的，让`CSS`独立于`HTML`会更有好处。

`CSSOM`树的构建和`DOM`如初一辙，都是按照字节数据&rarr;字符串&rarr;`Token`&rarr;节点&rarr;`CSSOM`的方式来构建。

上面的`CSS`会转为以下的树形结构。

![](cssom-tree.png)

那么问题来了，为什么`CSSOM`会存在树形结构？为页面上的任何对象计算最后一组样式（优先级相等的话后面的样式会覆盖前面的）时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是`body`元素的子项，则应用所有`body`样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。

这时生成的`CSSOM`树还不是完整的`CSSOM`树，因为它仅仅包含样式表中的样式，每个浏览器还有默认样式。`CSS`本质就是用我们自己写的样式替换元素或浏览器中的默认样式。

#### 浏览器解析 CSSOM 过程

##### 解析

首先将所有的选择器和属性都单独拿出来，简写的属性方法会转为全称，例如`border`转化为对应的`border-color`，`border-width`。选择器，属性，值三个部分一一对应。解析选择器是从右到左解析的。

##### 计算

将所有样式拿出来以后，就会对他们进行样式计算，例如`1em`会计算成`16px`，任何维度的值都会转为三种可能的值（`px`，`auto`，`%`）之一。

##### 级联

之后到了级联规则，`CSS`来源有很多种，有浏览器默认样式，内联样式，还有各种选择器的优先级都需要被计算。这就需要一种用来确定哪些样式应该应用给哪些元素的方法，具体顺序如下。

`!important` > 内联 > ID > 类 > 标签 | 伪类 | 属性选择 > 伪对象 > 通配符 > 继承

多个选择器优先级可以叠加。

![](calculate.png)

每出现一个，就在对应的位置上加 1，第二个是内联样式。如果优先级相等，后面的会覆盖前面的。这个计算方法是不进位的。

从来源上说，网页作者的样式优先级大于用户的优先级大于浏览器默认样式的优先级。

最后浏览器会将整理的所有样式先按照来源排序，再按照特性排序，最后按照文档顺序排序。

所谓的级联就是`CSS`的显示规则，因为`CSS`全名就叫级联（层叠）样式表。但是还有一个问题，如果使用了元素选择器可以生成树结构，使用类选择器的树结构从哪里来的呢？大概浏览器内部会对应的`HTMl`中找一下。

##### 最终结果

最后会将之前计算好的结果放入`document.styleSheets`中。

![](stylesheet.jpg)

## 渲染树构建，布局及绘制

`CSSOM`树和`DOM`树合并成渲染树，然后用于计算每个可见元素的布局，并输出给绘制流程，将像素渲染到屏幕上。

### 合并成渲染树

第一步是让浏览器将`DOM`和`CSSOM`合并成一个“渲染树”，网罗网页上所有可见的`DOM`内容，以及每个节点的所有`CSSOM`样式信息。渲染树只包含渲染网页所需的节点，像`display:none`的节点不在渲染树中出现，但是`visibility:hidden`会占据布局空间。

![](render-tree-construction.png)

浏览器首先从`DOM`树的根节点遍历每个可见节点，像脚本标记，元标记等不可见节点不会加到渲染树种。某些节点通过`CSS`隐藏也不会加入渲染树中。之后对于每个可见节点，为其找到适配的`CSSOM`规则并应用它们。最后发射可见节点，将其内容和样式一起发射到布局阶段进行布局计算。

### 布局阶段

最终输出的渲染树中同时包含了屏幕上的所有可见内容及其样式信息。有了渲染树，就可以进入布局阶段。

现在已经有了节点信息和节点对应的样式信息，但还没计算他们在设备窗口内的确切位置和大小。这就是布局阶段，也叫自动重排。

布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸：所有相对测量值都转换为屏幕上的绝对像素。

在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。

布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，如果没有层叠上下文或裁剪的元素，那么会直接将渲染树转换成屏幕上的像素（绘制）。

### 分层阶段

我们知道了哪些节点可见、它们的计算样式以及几何信息，但是页面还有一些复杂的效果，如`3D`变换，页面滚动，`z-idnex`做的`z`轴排序等。渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。这个可以通过开发者工具的`Layers`页签看到分层情况。

图层树和布局树会有对应关系，如果一个节点没有对应的图层，那么这个节点就从属于父节点的图层。拥有层叠上下文属性的元素会被提升为单独的一层，明确定位属性的元素、定义透明属性的元素、使用`CSS`滤镜的元素等，都拥有层叠上下文属性。需要剪裁（clip）的地方（`overflow`属性）也会被创建为图层，如果出现滚动条，滚动条也会被提升为单独的层。

### 图层绘制

渲染引擎实现图层的绘制会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

### 栅格化操作

绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。

页面很大，但是用户只能看到一个视口的部分。例如有的图层你需要滚动才能看全，但是通过视口只能看到一小部分，如果全部绘制是没必要的。合成线程会将图层划分为图块（栅格化执行最小单位），然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。

这个绘制过程可能会调用`GPU`，这就涉及到跨进程操作。生成的位图会存在`GPU`内存中。

### 合成和显示

所有图块都被栅格化之后，合成线程发出一个`DrawQuad`指令，浏览器的`viz`组件收到这个指令后，将页面内容绘制到内存中，最后显示在屏幕上。

## 简单的渲染

- 处理`HTML`标记并构建`DOM`树。
- 处理`CSS`标记并构建`CSSOM`树。
- 将`DOM`与`CSSOM`合并成一个渲染树。
- 根据渲染树来布局，以计算每个节点的几何信息。
- 将各个节点绘制到屏幕上。

## 复杂的渲染

- 渲染进程将`HTML`内容转换为能够读懂的`DOM`树结构。
- 渲染引擎将`CSS`样式表转化为浏览器可以理解的`styleSheets`，计算出`DOM`节点的样式。
- 创建布局树，并计算元素的布局信息。
- 对布局树进行分层，并生成分层树。
- 为每个图层生成绘制列表，并将其提交到合成线程。
- 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
- 合成线程发送绘制图块命令`DrawQuad`给浏览器进程。
- 浏览器进程根据`DrawQuad`消息生成页面，并显示到显示器上

## CSSOM 阻塞渲染

### DOM 的角度

从`DOM`的角度来说，`CSSOM`不会阻塞`DOM`的解析，因为`CSS`不会改变`DOM`的结构。

### render tree 的角度

从渲染树的角度来说，必须同时具有`DOM`和`CSSOM`才能构建渲染树，所以`CSSOM`必定会阻塞渲染。`HTML`就不用说了，这是必须有的。

默认情况下。`CSS`会被认为是阻塞渲染的资源，如果设置为不阻塞渲染，浏览器也会下载所有`CSS`资源，这时浏览器会出现“内容短暂失效”（FOUC）。即浏览器现将文档渲染出来，之后`CSS`加载好后会出现无样式显示页面内容的情况。

这就说明`CSS`阻塞渲染的必要性，需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。

可以通过媒体查询来控制`CSS`是否在浏览器中阻塞渲染。

```html
<link href="style.css" rel="stylesheet" /> /* 阻塞渲染*/
<link href="style.css" rel="stylesheet" media="all" />/* 阻塞渲染*/
<link href="portrait.css" rel="stylesheet" media="orientation:portrait" />/*
视页面加载方向阻塞渲染*/
<link href="print.css" rel="stylesheet" media="print" />/*不阻塞渲染*/
```

### JavaScript 脚本的角度

如果脚本加载好了，但是样式文件还没有解析完毕，`CSSOM`树还没有构建结束，而我们却想在此时运行脚本，会怎样？答案很简单，对性能不利：浏览器将延迟脚本执行和`DOM`构建，直至其完成`CSSOM`的下载和构建。

这也是为什么要将`<style>`标签放在头部，`<script>`标签放在尾部的原因。

## JavaScript 阻塞渲染

`JavaScript`可以修改和查询`DOM`与`CSSOM`，在渲染过程中，好像并没有`JavaScript`的环节，因为`JavaScript`很特殊，在渲染页面层次上来讲并不必要。本质上浏览器的核心功能就是展示页面，`JS`脚本只是在**渲染树**之前给我们一个可以修改`HTML`和`CSS`的方式。这里讲的阻塞只是针对渲染树之前的时间段。

### DOM 的角度

如果在`DOM`解析过程中解析到了`<script>`标签，浏览器会直接下载对应的脚本文件。如果`<script>`标签中没有添加`defer`或`async`属性，那么浏览器在下载脚本文件时就会阻塞`DOM`和`CSSOM`渲染。所以`defer`或`async`属性很重要。如果是内联代码，则省去了下载时间，直接在加载时阻塞。

### CSSOM 的角度

如果脚本开始执行，但是`CSSOM`还没开始构建，那么会阻止`CSSOM`的构建。如果脚本没执行，则参照上边，`CSSOM`阻塞`JS`脚本的执行。

### 总结

- 脚本在文档中的位置很重要。
- 当浏览器遇到一个`script`标记时，`DOM`构建将暂停，直至脚本完成执行。
- `JavaScript`可以查询和修改`DOM`与`CSSOM`。
- `JavaScript`执行将暂停，直至`CSSOM`就绪。

## 异步加载

可以在`<script>`标签上增加属性`defer`或者`async`。个人认为`defer`会比`async`好一点，从并行加载的角度来说，二者都能提高性能。但是`defer`更符合预期，因为它是`DOM`树加载之后才运行脚本的。`async`对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的

![](async.jpeg)

## 相关问题

### DOM 和 CSSOM 加载可以同时进行吗

可以的，在加载页面时可以看到页面不是一下子全出来的，这就说明浏览器可以加载一部分渲染一部分。

### window.onload 和 DOMContentLoaded 的区别

`DOMContentLoaded`方法是在`HTML`被完全解析之后触发的事件，并不需要（样式表/图像/子框架）加载完成之后再进行。

`window.onload`用于检测一个加载完全的页面。

### 渲染对象和渲染树是一一对应的吗

不是，一个渲染树的节点对象可能对应着多个盒子。

### 回流，重绘，直接合成阶段

回流：也叫重排，通过`JavaScript`或者`CSS`修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。

重绘：如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。

直接合成阶段：如果你更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，这个过程叫做合成。使用了`CSS`的`transform`来实现动画效果，这可以避开重排和重绘阶段。相对于重绘和重排，合成能大大提升绘制效率。

### 什么是脏位系统

大多数`web`应用对`DOM`的操作都是比较频繁，这意味着经常需要对`DOM`进行布局和回流，而如果仅仅是一些小改变，就触发整个渲染树的回流，这显然是不好的，为了避免这种情况，浏览器使用了脏位系统，只有一个渲染对象改变了或者某渲染对象及其子渲染对象脏位值为`dirty`时，说明需要回流。

- `dirty`：自身改变，需要回流
- `children are dirty`：子节点改变，需要回流

### CSSOM 怎么加载行内样式

和类名一样，行内样式也可以直接从`HTML`文档中获得，其实一个正则就能拿出来了。这个获取是伴随着`CSS`解析开始的。

### 如何性能优化

减少文件大小，脚本在文档中的位置很重要，`CSS`选择器，下载内容是否需要在首屏展示。
