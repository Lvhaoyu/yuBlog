---
title: 图解http第八章
tags:
  - web前端
  - 网络基础
categories:
  - 读书笔记
  - 图解HTTP
date: 2020-01-20 19:50:53
visible:
---

# 确认访问用户身份的认证

对于一个系统来说，不同的用户会有不同的权限，对应着不同的页面。为了实现这个需求，就需要引入认证机制。

## 何为认证

计算机无法判断使用者的身份，只能通过客户端传送的信息才能确认是谁在访问服务器。服务端需要通过客户端传输来的能证明登录者信息的报文才能确认登录者的权限。

核对的信息包括：

- 密码：只有本人才会知道的字符串信息。

- 动态令牌：仅限本人持有的设备内显示的一次性密码。

- 数字证书：仅限本人（终端）持有的信息。

- 生物认证：指纹和虹膜等本人的生理信息。

- IC 卡等：仅限本人持有的信息。

如果其他人掌握了这些信息，也可以冒充真实的登录者，所以这些机密的信息不能被其他人获取和破解。

`HTTP/1.1`的认证方式如下:

- BASIC 认证（基本认证）

- DIGEST 认证（摘要认证）

- SSL 客户端认证

- FormBase 认证（基于表单认证）

## BASIC 认证

![](00159.jpeg)

1. 当请求的资源需要`BASIC`认证时，服务器会随状态码`401 Authorization Required`，返回带`WWW-Authenticate`首部字段的响应。该字段内包含认证的方式（BASIC）及`Request-URI`安全域字符串（realm）。

2. 接收到状态码`401`的客户端为了通过`BASIC`认证，需要将用户`ID`及密码发送给服务器。发送的字符串内容是由用户`ID`和密码构成，两者中间以冒号（:）连接后，再经过`Base64`编码处理，用户只需要输入字符串，编码会交由给浏览器自动完成。

3. 接收到包含首部字段`Authorization`请求的服务器，会对认证信息的正确性进行验证。如验证通过，则返回一条包含`Request-URI`资源的响应。

本方法没有对用户名和密码进行加密处理，明文解码即可获取用户名和密码。在非加密通信线路可以很容易的被窃听。如果想再一次进行认证，一般浏览器没有办法实现注销功能，所以并不常用。

## DIGEST 认证

`DIGEST`认证在`HTTP/1.1`中加入，和`DIGEST`一样使用质询/响应的方式，但是不发送明文密码。

> 质询响应方式：所谓质询响应方式是指，一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。

### 认证步骤

![](00162.jpeg)

1. 请求需认证的资源时，服务器会随着状态码`401 Authorization Required`，返回带`WWW-Authenticate`首部字段的响应。该字段内包含质问响应方式认证所需的临时质询码（随机数，nonce）。首部字段`WWW-Authenticate`内必须包含`realm`和`nonce`这两个字段的信息。客户端就是依靠向服务器回送这两个值进行认证的。`qop`的`auth`表示鉴别方式。

> nonce：是一种每次随返回的 401 响应生成的任意随机字符串。该字符串通常推荐由 Base64 编码的十六进制数的组成形式，但实际内容依赖服务器的具体实现。

2. 接收到`401`状态码的客户端，返回的响应中包含`DIGEST`认证必须的首部字段 `Authorization`信息。

> 首部字段 Authorization 内必须包含 username、realm、nonce、uri 和 response 的字段信息。其中，realm 和 nonce 就是之前从服务器接收到的响应中的字段。uri 中存储着 Request-URI 的副本，为了防止 Request-URI 被修改。response 也可叫做 Request-Digest，存放经过 MD5 运算后的密码字符串，形成响应码。

3. 接收到包含首部字段`Authorization`请求的服务器，会确认认证信息的正确性。认证通过后则返回包含`Request-URI`资源的响应。这时会在首部字段`Authentication-Info`写入一些认证成功的相关信息。

该认证方式与前者（BASIC）相比，不外乎多了一个密码的`MD5`加密，这样可以防止密码被窃听后不能被直接查看，但是没办法防止伪装。

> 伪装主要有以下几点：
>
> - 客户端无法确认自己的请求是否发送到了目标服务器或者返回响应的服务器是否是目标服务器，有可能是伪装了的服务器。
> - 服务器无法确认向自己发起请求的客户端以及自己返回响应的客户端是否是目标中的客户端。
> - 无法确认通信方是否具备访问权限，因为某些服务器只想给特定的用户访问。
> - 即使是无意义的请求也会照单全收，使得服务器可能遭受到 DDoS 攻击。

## SSL 客户端认证

前两者是基于账号密码的验证，只要这二者内容正确，就认证是本人的行为。但如果账号密码被盗，就可以被第三方冒充。也没有解决存在**伪装**的问题。

`SSL`客户端认证是借由`HTTPS`的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。

### 认证步骤

为达到`SSL`客户端认证的目的，需要事先将客户端证书分发给客户端，且客户端必须安装此证书。

1. 接收到需要认证资源的请求，服务器会发送`Certificate Request`报文，要求客户端提供客户端证书。

2. 用户选择将发送的客户端证书后，客户端会把客户端证书信息以`Client Certificate` 报文方式发送给服务器。

3. 服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始`HTTPS`加密通信。

刚一看有点懵，但是思考一下日常生活中的例子，就可以很好地理解。在浏览器中使用银行转账的时候，会让你安装一个证书，那就是客户端证书。日常使用的客户端证书很少见，一般都是涉及到钱的时候才会让客户手动安装或者有一个所谓的盾牌（往电脑上插的那种），不要和服务端证书混淆。

使用客户端证书是需要费用的，这也是没有普及的主要原因。

### SSL 客户端认证采用双因素认证

所谓双因素认证就是指，认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式。

`SSL`客户端认证使用账号密码和证书双认证，通过双因素认证后，就可以确认是用户本人正在使用与证书匹配正确的计算机访问服务器。

## 基于表单认证

基于表单的认证方法并不是在`HTTP`协议中定义的。客户端会向服务器上的`Web`应用程序发送登录信息（Credential），按登录信息的验证结果认证。

日常使用中碰到的大部分都是表单认证，输入已事先注册的用户`ID`（通常是任意字符串或邮件地址）和密码等登录信息后，发送给`Web`应用程序，基于认证结果来决定认证是否成功。

表单验证的账号密码和`BASIC`，`DIGEST`中的账号密码不是一个范畴，表单验证的账号密码是直接在页面上输入。而后两者的账号密码是服务端（浏览器）收到响应报文后根据报文信息自己弹出来。

由于客户端证书存在导入和维持的费用，所以并不普及。表单验证也没有固定的规范，都是由`Web`应用程序各自实现基于表单的认证方式，安全等级也由于技术实现不同而不同。

## Session 管理及 Cookie 应用

基于表单认证的标准规范并未定义，一般都是使用`Cookie`来管理`Session`。其本身是通过服务器端的`Web`应用，将客户端发送过来的用户`ID`和密码与之前登录过的信息做匹配来进行认证的。

但是由于由于`HTTP`是无状态协议，无法实现状态管理，`Cookie`和`Session`正是用来给`HTTP`增加状态管理的功能。

![](00165.jpeg)

状态管理步骤如下：

1. 客户端把用户`ID`和密码等登录信息放入报文的实体部分，通常是以`POST`方法把请求发送给服务器。而这时，会使用`HTTPS`通信来进行`HTML`表单画面的显示和用户输入数据的发送。
2. 服务器会发放用以识别用户的`Session ID`。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与`Session ID`绑定后记录在服务器端。向客户端返回响应时，会在首部字段`Set-Cookie`内写入`Session ID`。为了防止`Session ID`泄露，应该使用难以推测的字符串，而且最好事先在`Cookie`内部增加`httponly`属性。
3. 客户端接收到从服务器端发来的`Session ID`后，会将其作为`Cookie`保存在本地。下次向服务器发送请求时，浏览器会自动发送`Cookie`，所以`Session ID`也随之发送到服务器。服务器端可通过验证接收到的`Session ID`识别用户和其认证状态。

除此之外，服务端保存密码也需要保证安全性。一种安全的保存方法是，先利用给密码加盐（salt）的方式增加额外信息，再使用散列（hash）函数计算出散列值后保存。

> salt 其实就是由服务器随机生成的一个字符串，但是要保证长度足够长，并且是真正随机生成的。然后把它和密码字符串相连接（前后都可以）生成散列值。当两个用户使用了同一个密码时，由于随机生成的 salt 值不同，对应的散列值也将是不同的。这样一来，很大程度上减少了密码特征，攻击者也就很难利用自己手中的密码特征库进行破解
