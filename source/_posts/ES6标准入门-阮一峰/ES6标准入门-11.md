---
title: ES6标准入门-11
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-03-01 16:47:39
visible:
---

# Proxy 和 Reflect

## Proxy

`Proxy`在字面表示代理的意思，在`JS`中相当于一个代理商，连通了用户和`JS`对象，用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。

使用`Proxy`可以在目标对象之前架设一层“拦截”，外界对该对象的访问必须先通过这层拦截。可以对外界的访问进行过滤和改写。

### 如何使用

首先要有一个`Object`（供应商），里面存在着业务需要的原始数据。之后通过`Proxy`（代理商）新生成一个对象，最终用户访问的是通过`Proxy`新生成的对象，不会访问原始对象。

```js
var proxy = new Proxy(target, handler);
```

`ES6`提供原生`Proxy`构造函数，用来生成`Proxy`实例，第一个参数是要代理的目标对象，第二个参数也是一个对象，用来定制拦截行为。如果`handler`没有定制任何行为（为一个空对象），那就等于直接通向源对象。`Proxy`可以作为其他对象的原型对象。

```js
let obj = {
  time: '2020-03-01',
  name: 'net',
  _r: 123
};

let monitor = new Proxy(obj, {
  // 拦截对象属性的读取
  get(target, key) {
    return target[key].replace('2020', '2021');
  },
  // 拦截对象设置属性
  set(target, key, value) {
    if (key === 'name') {
      return (target[key] = value);
    } else {
      return target[key];
    }
  }
});

console.log('get', monitor.time); // get 2021-03-01
monitor.time = 2022;
console.log('set', monitor.time); // set 2021-03-01
monitor.name = 'hello';
console.log('set2', monitor.name); // set2 hello
```

从上述例子可知，代理在对象和用户之间起到的一个作用，就是代理可以规定用户操作对象的行为。原始对象只能通过代理操作，可以针对不同的场景在代理中设置不同的方法。

### 代理的方法

代理拦截器有 13 个方法，通过这些方法的组合来实现对各种对象操作的拦截。

#### get()

该方法用来拦截某个属性的读取操作，可以接收三个参数，目标对象，属性名和`Proxy`实例本身（操作行为针对的对象），第三个参数可以缺省。

![](111.jpg)

`get()`方法可以继承。`get`第三个参数总是指向原始的读操作所在的那个对象，一般情况下就是`Proxy`实例。

```js
const proxy = new Proxy(
  {},
  {
    get: function(target, key, receiver) {
      return receiver;
    }
  }
);
proxy.getReceiver === proxy; // true
```

#### set()

`set()`用来拦截某个属性的赋值操作，可以接收四个参数，目标对象，属性名，属性值和`Proxy`实例本身，最后一个参数可以缺省。如果目标对象自身的某个属性，不可写也不可配置（writable），那么`set`方法不起作用。在严格模式下，`set`代理如果没有返回`true`会报错。

#### apply()

该方法拦截函数的调用，`call`和`apply`操作。可以接收三个参数，目标对象，目标对象的上下文对象（this）和目标对象的参数数组。

```js
var target = function() {
  return 'I am the target';
};
var handler = {
  apply: function() {
    return 'I am the proxy';
  }
};

var p = new Proxy(target, handler);

p();
// "I am the proxy"
```

每当执行`proxy`函数（直接调用或`call`和`apply`调用），就会被`apply`方法拦截。

#### has()

该方法用来拦截`hasProperty`操作，注意与`hasOwnProperty`的区别，前者是判断继承和自身的属性，后者是只判断对象自身的属性。该方法对`for...in...`不生效。

可以接收两个参数，分别是目标对象，需要查询的属性名。

```js
var handler = {
  has(target, key) {
    if (key[0] === '_') {
      return false;
    }
    return key in target;
  }
};
var target = { _prop: 'foo', prop: 'foo' };
var proxy = new Proxy(target, handler);
'_prop' in proxy; // false
```

#### construct()

该方法拦截`new`命令，可以接收三个参数，目标对象，构造函数的参数对象，创造实例对象时的构造函数。必须返回一个对象，否则会报错。

```js
var p = new Proxy(function() {}, {
  construct: function(target, args) {
    console.log('called: ' + args.join(', '));
    return { value: args[0] * 10 };
  }
});
// 第三个参数就是 p
new p(1).value;
// "called: 1"
// 10
```

#### deleteProperty()

拦截`delete`操作，如果这个方法抛出错误或返回`false`，当前属性就无法被`delete`命令删除。对象属性自身的不可配置（configurable）属性不能被该方法删除。

```js
var handler = {
  deleteProperty(target, key) {
    invariant(key, 'delete');
    delete target[key];
    return true;
  }
};
function invariant(key, action) {
  if (key[0] === '_') {
    throw new Error(`Invalid attempt to ${action} private "${key}" property`);
  }
}

var target = { _prop: 'foo' };
var proxy = new Proxy(target, handler);
delete proxy._prop;
// Error: Invalid attempt to delete private "_prop" property
```

#### defineProperty()

该方法拦截`Object.defineProperty`操作。如果被拦截的对象是不可扩展，不能增加目标对象上不存在的属性。如果目标对象属性不可写也不可配置，`defineProperty`也不可以改变这两个配置。

```js
var handler = {
  defineProperty(target, key, descriptor) {
    return false;
  }
};
var target = {};
var proxy = new Proxy(target, handler);
proxy.foo = 'bar'; // 不会生效
```

#### getOwnPropertyDescriptor()

`getOwnPropertyDescriptor`方法拦截`Object.getOwnPropertyDescriptor()`，返回一个属性描述对象或者`undefined`。

```js
var handler = {
  getOwnPropertyDescriptor(target, key) {
    if (key[0] === '_') {
      return;
    }
    return Object.getOwnPropertyDescriptor(target, key);
  }
};
var target = { _foo: 'bar', baz: 'tar' };
var proxy = new Proxy(target, handler);
Object.getOwnPropertyDescriptor(proxy, 'wat');
// undefined
Object.getOwnPropertyDescriptor(proxy, '_foo');
// undefined
Object.getOwnPropertyDescriptor(proxy, 'baz');
// { value: 'tar', writable: true, enumerable: true, configurable: true }
```

#### getPrototypeOf()

拦截获取对象原型的操作，返回值必须为对象或者`null`，如果目标对象不可扩展，该方法必须返回其原型对象。

- `Object.prototype.__proto__`
- `Object.prototype.isPrototypeOf()`
- `Object.getPrototypeOf()`
- `Reflect.getPrototypeOf()`
- `instanceof`

```js
var proto = {};
var p = new Proxy(
  {},
  {
    getPrototypeOf(target) {
      return proto;
    }
  }
);
Object.getPrototypeOf(p) === proto; // true
```

#### ownKeys()

用来拦截对象自身属性的读取操作，返回数组成员中的值必须是字符串或`Symbol`，如果目标对象自身包含不可配置的属性，该属性必须被返回。如果目标对象不可扩展，返回的数组之中必须包含源对象的所有属性。主要拦截以下几种操作：

- `Object.getOwnPropertyNames()`
- `Object.getOwnPropertySymbols()`
- `Object.keys()`
- `for...in`循环

```js
let target = {
  a: 1,
  b: 2,
  c: 3
};

let handler = {
  ownKeys(target) {
    return ['a'];
  }
};

let proxy = new Proxy(target, handler);

Object.keys(proxy);
// [ 'a' ]
```

#### preventExtensions()

`preventExtensions`方法拦截`Object.preventExtensions()`。该方法必须返回一个布尔值，否则会被自动转为布尔值。

只有目标对象不可扩展（`Object.isExtensible(proxy) === false`），该方法才能返回`true`。

一般会在该方法中再调用一次`Object.preventExtensions`。

```js
var proxy = new Proxy(
  {},
  {
    preventExtensions: function(target) {
      console.log('called');
      Object.preventExtensions(target);
      return true;
    }
  }
);

Object.preventExtensions(proxy);
// "called"
// Proxy {}
```

#### setPrototypeOf()

`setPrototypeOf`方法主要用来拦截`Object.setPrototypeOf`方法（设定一个指定的原型到另一个对象或者`null`）。

```js
var handler = {
  setPrototypeOf(target, proto) {
    throw new Error('Changing the prototype is forbidden');
  }
};
var proto = {};
var target = function() {};
var proxy = new Proxy(target, handler);
Object.setPrototypeOf(proxy, proto);
// Error: Changing the prototype is forbidden
```

只能返回布尔值，否则会自动转为布尔值。如果目标对象不可扩展，该方法不得修改其原型。

#### isExtensible(target)

拦截`Object.isExtensible(proxy)`，返回一个布尔值。用于判断对象是不是可扩展的。

### Proxy.revocable()

`Proxy.revocable`方法返回一个可取消的`Proxy`实例。

```js
let target = {};
let handler = {};

let { proxy, revoke } = Proxy.revocable(target, handler);

proxy.foo = 123;
proxy.foo; // 123

revoke();
proxy.foo; // TypeError: Revoked
```

`Proxy.revocable`方法返回一个对象，该对象的`proxy`属性是`Proxy`实例，`revoke`属性是一个函数，可以取消`Proxy`实例。上面代码中，当执行`revoke`函数之后，再访问`Proxy`实例，就会抛出一个错误。

适合访问结束直接收回代理权的操作。

### this 问题

`Proxy`可以代理目标对象的访问，但它不是透明代理，不做任何拦截的情况下，也不能保证与目标对象行为一致，因为在`Proxy`代理的情况下，目标对象内部`this`关键字会指向`Proxy`代理。

有些原生对象的内部属性，只有通过正确的`this`才能拿到，所以`Proxy`也无法代理这些原生对象的属性。

```js
const target = new Date();
const handler = {};
const proxy = new Proxy(target, handler);

proxy.getDate();
// TypeError: this is not a Date object.
```

## Reflect

### 基本概念

`Reflect`是一个内置的对象，提供拦截`JS`操作的方法，可以认为是为了操作对象而提供的新`API`。和`Math`类似，不可以构造，只能调`API`。

### 目的

- 将某些语言内部的方法放到`Reflect`对象上。
- 顺便修改`Object`中返回值不合理的方法。
- 让`Object`操作都变成函数行为。
- `Reflect`方法与`Proxy`一一对应，可以让`Proxy`方便调用对应的`Reflect`方法，完成默认行为，作为修改行为的基础。

### 静态方法

`Reflect`没有静态属性，和`Proxy`一一对应有 13 个静态方法。

## Proxy 和 Reflect 实现观察者模式

观察者模式就是函数自动观察数据对象，一旦对象有变化，函数自动执行。

```js
const queuedObservers = new Set();

const observe = fn => queuedObservers.add(fn);
const observable = obj => new Proxy(obj, { set });

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer => observer());
  return result;
}

// 观察目标
const person = observable({
  name: '张三',
  age: 20
});

// 观察者
function print() {
  console.log(`${person.name}, ${person.age}`);
}

observe(print);
person.name = '李四';
// 输出
// 李四, 20
```

上面代码中，先定义了一个`Set`集合，所有观察者函数都放进这个集合。然后，`observable`函数返回原始对象的代理，拦截赋值操作。拦截函数`set`之中，会自动执行所有观察者。

## Proxy 实现个人信息校验与业务解耦

```js
function validator(target, validator) {
  return new Proxy(target, {
    _validator: validator,
    set(target, key, value, proxy) {
      if (target.hasOwnProperty(key)) {
        let va = this._validator[key];
        if (!!va(value)) {
          return Reflect.set(target, key, value, proxy);
        } else {
          throw Error(`不能设置${key}到${value}`);
        }
      } else {
        throw Error(`${key} 不存在`);
      }
    }
  });
}

const personValidators = {
  name(val) {
    return typeof val === 'string';
  },
  age(val) {
    return typeof val === 'number' && val > 18;
  }
};
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
    return validator(this, personValidators);
  }
}

const person = new Person('lilei', 11);
console.log(person);

person.name = 48;
```
