---
title: ES6标准入门-3
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-02-13 10:32:28
visible:
---

# 字符串的扩展

`ES6`对字符串的扩展体现在增强了对`Unicode`的支持，并且在字符串对象和实例上增加了很多方法。

## 字符的`Unicode`表示法

`JavaScript`允许采用`\uxxxx`形式来表示一个字符，`\u`后边的表示字符的`Unicode`码点，需要采用 16 进制。

由于`JavaScript`使用`UTF-16`编码，可以使用二到四个字节来表示一个字符。如果字符范围超出`\u0000~\uFFFF`，就需要使用四个字节来表示，也就是两个双字节来表示一个字符。而对应表示的字符也会被解析成一个代码单元。

对于这种超出范围的编码，`JavaScript`允许将码点放入大括号中，就能正确的解释该字符。

```JavaScript
"\u{20BB7}"
// "𠮷"

"\u20BB7"
// " 7" 不使用大括号会被解析成 \u20BB+7
```

综上`JavaScript`可以有六种方式表示一个字符：

```JavaScript
'\z' === 'z'  // true
'\172' === 'z' // true
'\x7A' === 'z' // true
'\u007A' === 'z' // true
'\u{7A}' === 'z' // true
```

## 字符串新增与字符编码有关的方法

### codePointAt()

该方法是`charCodeAt`的扩充，参数为字符在字符串内的索引，返回值为给定索引处字符的`UTF-16`代码单元值的数字（十进制），如果超出范围则返回`NaN`。

对于`charCodeAt`来说，处理四个字节存储的字符会被当成两个字节的来处理。例如“𠮷”的处理，使用这两个方法的不同就可以很明显看出来：

```JavaScript
var s = "𠮷";

s.length // 2
s.charAt(0) // '' 该方法是返回字符串的第几个字符
s.charAt(1) // ''
s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271

let s = '𠮷a';

s.codePointAt(0) // 134071
s.codePointAt(1) // 57271
s.codePointAt(2) // 97
```

这个方法总是会返回十进制的码点值，但是该方法在查询四字节字符时第一个索引就可以正确识别该码点。四字节存储的第二个字符和其他两个字节存储的常规字符，行为与`charCodeAt`相同。

虽然该方法可以正确返回 32 位的`UTF-16`字符的码点，但是它的参数还是不对的。使用 32 位来码点的字符在传参时仍然按照两个长度来取值。可以使用`for...of...`循环来避免这个所谓的不合理之处。

```JavaScript
let s = '𠮷a';
for (let ch of s) {
  console.log(ch.codePointAt(0).toString(16));
}
```

也可以使用扩展运算符来进行展开运算：

```JavaScript
let arr = [...'𠮷a']; // arr.length === 2
arr.forEach(
  ch => console.log(ch.codePointAt(0).toString(16))
);
```

该方法也可以用来测试一个字符是否是两个字节还是四个字节组成：

```JavaScript
function is32Bit(c) {
  return c.codePointAt(0) > 0xFFFF;
}

is32Bit("𠮷") // true
is32Bit("a") // false
```

### String.fromCodePoint()

该方法用于从码点返回对应字符，是`String.fromCharCode()`方法的扩展，同样增加对 32 位`UTF-16`字符的支持。

使用`String.fromCharCode()`方法处理大于`0xFFFF`（65536）的码点时，多出的部分会直接将最高位截断。

`ES6`新方法`String.fromCodePoint()`是`codePointAt()`相反的方法，传入对应的`Unicode`代码点，返回对应的字符串，如果传入无效的代码点，会抛出错误。

该方法是静态方法，定义在`String`对象上，`codePointAt()`则是被定义在字符串的实例对象上。

```JavaScript
String.fromCodePoint(0x20BB7) // "𠮷"

String.fromCodePoint(0x1D306, 0x61, 0x1D307) // "\uD834\uDF06a\uD834\uDF07" 如果有多个参数，会被合并为一个字符串返回

String.fromCodePoint('_');      // RangeError
String.fromCodePoint(Infinity); // RangeError
String.fromCodePoint(-1);       // RangeError
String.fromCodePoint(3.14);     // RangeError
String.fromCodePoint(3e-2);     // RangeError
String.fromCodePoint(NaN);      // RangeError
```

### 字符串的遍历接口

`ES6`使得字符串可以通过`for...of...`循环遍历。该接口使用频率略高，需重视。

该方法最大的优点就是可以正常处理码点大于`0xFFFF`的字符。

```JavaScript
let text = String.fromCodePoint(0x20BB7);

for (let i = 0; i < text.length; i++) {
  console.log(text[i]);
}
// " "
// " "

for (let i of text) {
  console.log(i);
}
// "𠮷"
```

### normalize()

欧洲语言有很多是带重音的，为了表示它们，`Unicode`提供了两种方法，一种是直接提供符号，一种是提供两个符号拼在一起。

`ES6`提供了字符串实例上的的`normalize()`方法，用来将字符的不同表示方法统一为同样的形式，这称为`Unicode`正规化。该方法可以接收`Unicode`的四种正规格式之一作为参数，如果调用方法的值不是字符串，会将其先转换为一个字符串，如果参数错误会报错。

```JavaScript
'\u01D1'.normalize() === '\u004F\u030C'.normalize() // true
'\u004F\u030C'.normalize('NFC').length // 1
'\u004F\u030C'.normalize('NFD').length // 2
```

### Unicode 保留字

`JS`允许直接输入字符和字符的转义形式：

```JavaScript
'中' === '\u4e2d' // true
```

但是有五个字符不可以在字符串中使用，输入时需要进行转义或使用对应的`Unicode`编码：

![](111.jpg)

这个规定和`JSON`格式的文件有一些冲突，因为`JSON`允许行分隔符和段分隔符。好在`ES2019`已经允许字符串输入这两项。模板字符串一直可以输入这两项。

### JSON.stringify()的修改

`JSON`数据格式规定数据必须是`UTF-8`编码，它规定对于`0xD800`到`0xDFFF`之间的码点，不能单独使用，必须配对使用。但是`JSON.stringify()`可能会返回不能单独使用的码点。

`ES2019`修改了该方法，如果遇到上述范围的单个码点或不存在的配对形式，会返回转义字符串，交给用户自行处理。

```JavaScript
JSON.stringify('\u{D834}') // ""\\uD834""
JSON.stringify('\uDF06\uD834') // ""\\udf06\\ud834""
```

## includes()， startsWith()， endsWith()方法

这三个方法都是用来判断字符串中是否包含了另一个字符串的方法。之前只有`indexof`方法来判断，`ES6`新增了三种方法：

- includes()：返回布尔值，表示是否找到了参数字符串。
- startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
- endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。

都支持第二个参数，表示开始搜索的位置：

```JavaScript
let s = 'Hello world!';

s.startsWith('world', 6) // true 从 6 开始到结尾
s.endsWith('Hello', 5) // true 5 表示前五个字符
s.includes('Hello', 6) // false 从 6 开始到结尾
```

## repeat()

这个方法返回一个新的字符串，表示将原字符串重复`n`次。参数如果是小数，会被取整（向下）。负数和`Infinity`会报错。如果是`0 到 -1`之间的小数，则会被当成`0`计算。`NaN`会被当成`0`，字符串会先进行转换。

```JavaScript
'hello'.repeat(2) // "hellohello"
'na'.repeat(2.9) // "nana"
'na'.repeat(Infinity)
// RangeError
'na'.repeat(-1)
// RangeError
```

## padStart()，padEnd()

这两个方法是用来给字符串补全长度的功能。如果字符串不符合长度，会在头部或尾部补全。`padStart()`为头部补全，`padEnd()`为尾部补全。

接收两个参数，第一个是字符串补全生效的最大长度，第二个是用来补全的字符串。

```JavaScript
'x'.padStart(5, 'ab') // 'ababx'
'x'.padStart(4, 'ab') // 'abax'

'x'.padEnd(5, 'ab') // 'xabab'
'x'.padEnd(4, 'ab') // 'xaba'
```

如果需要补全的字符串长度超过了最大长度，返回原字符串。若用来补全的字符串超过了最大长度，会截掉对应超出的部分。省略第二个参数则使用空格补全。

```JavaScript
'xxx'.padStart(2, 'ab') // 'xxx'
'xxx'.padEnd(2, 'ab') // 'xxx'

'abc'.padStart(10, '0123456789') // '0123456abc'

'x'.padStart(4) // '   x'
'x'.padEnd(4) // 'x   '
```

常用用法是为数值补全指定位数和提示字符串的格式：

```JavaScript
'1'.padStart(10, '0') // "0000000001"
'12'.padStart(10, '0') // "0000000012"

'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
```

## trimStart()，trimEnd()

这两个方法和`trim()`的行为相同，都是用来消除字符串两侧的空格。`trimStart()`是消除字符串头部的空格，`trimEnd()`是消除字符串尾部的空格。返回新的字符串，不修改原字符串。

除了空格键，这三个方法对字符串头部（或尾部）的`tab`键、换行符等不可见的空白符号也有效。

## 模板字符串

模板字符串是增强版的字符串，使用反引号(就是数字键左边那个)符号表示。可以当做普通字符串，也可以定义多行字符串，也可以在字符串中嵌入变量。表示多行字符串时，所有的空格和缩进都会保留在输出之中。

```JavaScript
// 普通字符串
`In JavaScript '\n' is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
let name = "Bob", time = "today";
`Hello ${name}, how are you ${time}?`

let greeting = `\`Yo\` World!`; // 模板字符串中有反引号需要转义
```

模板字符串的`${}`可以放任何`JS`表达式，如果大括号中的值经过运算后不是字符串，则会被转为字符串。

### 标签模板

将模板字符串紧跟在一个函数名后边，该函数将被调用来处理这个模板字符串，这就是“标签模板”功能。

虽然被称为标签模板，但是也是函数调用的一种特殊形式。“标签”指的是函数，模板字符串就是“标签”的参数。

```JavaScript
alert`123` // 页面会弹出一个框
```

如果模板字符串中有变量，就麻烦了，需要将模板字符串先处理成多个参数，再调用函数：

![](222.jpg)

从截图中可以看出，第一个参数为一个数组，数组成员为没有变量替换的部分。这里面有一个小问题，就是当变量替换部分出现在字符串的首部或者尾部的时候，会多出一个空字符`""`，这是因为在解析的时候是按照`${}`来解析的。从技术的角度来说，在以`${}`作为基准点切割，左右都应该能切出东西，而这个空字符就是在某一侧没有其他字符时切割出来的。其中还有一个`raw`属性，该属性指向一个数组，数组成员与第一个参数完全一致。区别在于后者会将原始字符串中的斜杠转义，方便取得转义前的原始模板。

```JavaScript
strings: ["First line\nSecond line"];
strings.row: ["First line\\nSecond line"];
```

其他参数为模板字符串中各个变量被替换后的值。

“标签模板”的一个重要应用在于过滤`HTML`字符串，防止`XSS`攻击。另一个作用就是多语言转换。

过滤`HTML`字符串：

```JavaScript
let message =
  SaferHTML`<p>${sender} has sent you a message.</p>`;

function SaferHTML(templateData) {
  let s = templateData[0];
  for (let i = 1; i < arguments.length; i++) {
    let arg = String(arguments[i]);

    // Escape special characters in the substitution.
    s += arg.replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;");

    // Don't escape special characters in the template.
    s += templateData[i];
  }
  return s;
}
```

多语言转换：

```JavaScript
//  internationalization
i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`
```

### 模板字符串的限制

模板字符串可以内嵌其他语言，具体就是通过一个函数将其他的语言机制在内部实现一下。但是模板字符串默认会将字符串转义。例如对一些默认的`Unicode`进行转义，导致无法嵌入其他语言。

为了解决这个问题，`ES2018`放松了对标签模板里面字符串转义的限制，如果遇到不合法的字符串转义（运行时因为转义而报错的部分），就返回`undefined`，而不是报错，而且可以从`raw`属性上获得原始字符串。曲线救国，可以正常使用`raw`属性的值来处理。

这种放松值在标签模板解析字符串时生效，其他场合依然会报错。

### String.raw()

该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。即输入字符串是什么样子的，输出就是什么样子的，原封不动。

```JavaScript
String.raw`Hi\n${2+3}!`
// 实际返回 "Hi\\n5!"，显示的是转义后的结果 "Hi\n5!"

String.raw`Hi\u000A!`;
// 实际返回 "Hi\\u000A!"，显示的是转义后的结果 "Hi\u000A!"
```

该方法本质上是一个正常的函数，但是一般通过标签模板的方式来调用。如果想按照正常的函数来调用，它的第一个参数，应该是一个具有`raw`属性的对象，且`raw`属性的值应该是一个数组，对应模板字符串解析后的值。

作为函数，内部实现基本如下：

```JavaScript
String.raw = function (strings, ...values) {
  let output = '';
  let index;
  for (index = 0; index < values.length; index++) {
    output += strings.raw[index] + values[index];
  }

  output += strings.raw[index]
  return output;
}
```
