---
title: ES6标准入门-14
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-03-03 21:33:05
visible:
---


[toc]

# Generator 函数的语法

`Generator`函数是`ES6`异步编程的一个解决方案，在语法上，可以将它理解成一个状态机，封装了多个内部状态。

执行`Generator`函数会返回一个`Iterator`接口的对象，所以`Generator`函数除了状态机，还是一个遍历器生成函数。返回的遍历器对象，可以依次遍历`Generator`函数内部的每一个状态。

代码形式上比普通函数多了一个`*`号，内部使用`yield`表达式，定义不同的内部状态。

```js
function* helloWorldGenerator() {
  yield 'hello';
  yield 'world';
  return 'ending';
}

var hw = helloWorldGenerator();
```

调用`Generator`函数之后，函数不执行，返回的是一个遍历器对象，之后调用`next`一步一步的执行。直到遇到`yield`表达式或`return`语句。`Generator`函数是分段执行的，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行。

![](111.jpg)

`ES6`没`function`关键字与函数名之间的`*`号写在哪个位置，所以下面的写法都能通过。

```js
function * foo(x, y) { ··· }
function *foo(x, y) { ··· }
function* foo(x, y) { ··· }
function*foo(x, y) { ··· }
```

## yield 表达式

`yield`可以看做暂停执行函数暂停的标志，由于返回的是遍历器对象，使用`next`进行下一次遍历，而`yield`就是遍历本次遍历结束的标志。

`next`方法运行逻辑如下：

1. 遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。

2. 下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。

3. 如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。

4. 如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。

`yield`表达式后面的表达式只有`next`指到了才会执行，等同于手动的**惰性求值**的功能。

`yield`与`return`的相似之处在于都能返回紧跟在语句后面那个表达式的值。区别在于每次遇到`yield`，函数暂停执行，下一次再从该位置继续向后执行，而`return`语句不具备位置记忆的功能。一个函数里只能有一个`return`，但是可以执行多次`yield`语句。

`Generator`函数可以不用`yield`表达式，这时就变成了一个单纯的暂缓执行函数。即调用`next`后直接执行完毕。

```js
function* f() {
  console.log('执行了！');
}

var generator = f();

setTimeout(function() {
  generator.next();
}, 2000);
```

函数`f`如果是普通函数，在为变量`generator`赋值时就会执行。但是，函数`f`是一个 `Generator`函数，就变成只有调用`next`方法时，函数`f`才会执行。

`yield`只能在`Generator`函数中使用，普通函数使用会报错。如果在`Generator`函数中的表达式中使用，也要加括号。

```js
function* demo() {
  console.log('Hello' + yield); // SyntaxError
  console.log('Hello' + yield 123); // SyntaxError
  console.log('Hello' + (yield)); // OK
  console.log('Hello' + (yield 123)); // OK
}
```

`yield`表达式用作函数参数或放在赋值表达式的右边，可以不加括号。

```js
function* demo() {
  foo(yield 'a', yield 'b'); // OK
  let input = yield; // OK
}
```

## yield 与 Iterator 接口的关系

任意一个对象的`Symbol.iterator`方法， 等于该对象的遍历器生成函数，调用该函数会返回该对象的的一个遍历器接口。

`Generator`就是遍历器生成函数，可以把`Generator`赋值给对象的`Symbol.iterator`属性，从而使得该对象有`Iterator`接口。

```js
var myIterable = {};
myIterable[Symbol.iterator] = function*() {
  yield 1;
  yield 2;
  yield 3;
};

[...myIterable]; // [1, 2, 3]
```

`Generator`函数执行之后，返回一个遍历器对象。该对象本身也具有`Symbol.iterator`属性，执行后返回自身。

```js
function* gen() {
  // some code
}

var g = gen();

g[Symbol.iterator]() === g;
// true
```

## next 方法的参数

`yield`表达式本身没有返回值，或者说返回值总是`undefined`。`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。

```js
function* f() {
  for (var i = 0; true; i++) {
    var reset = yield i;
    if (reset) {
      i = -1;
    }
  }
}

var g = f();

g.next(); // { value: 0, done: false }
g.next(); // { value: 1, done: false }
g.next(true); // { value: 0, done: false }
```

在`g.next(true)`运行之后，`rest`为`true`，否则为`undefined`。函数体内部`for`循环会触发`if`语句，会从`-1`开始增加。

这个功能的意义在于，`Generator`函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过`next`方法的参数，就有办法在`Generator`函数开始运行之后，继续向函数体内部注入值。也就是说，可以在`Generator`函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。

```js
function* foo(x) {
  var y = 2 * (yield x + 1);
  var z = yield y / 3;
  return x + y + z;
}

var a = foo(5);
a.next(); // Object{value:6, done:false}
a.next(); // Object{value:NaN, done:false}
a.next(); // Object{value:NaN, done:true}

var b = foo(5);
b.next(); // { value:6, done:false }
b.next(12); // { value:8, done:false }
b.next(13); // { value:42, done:true }
```

由于`next`方法的参数表示上一个`yield`表达式的返回值，所以第一次使用`next`方法时，传递参数无效。`V8`引擎会自动忽略第一次使用`next`方法的参数，只有从第二次使用参数才有效。

## for...of... 循环

`for...of...`循环可以自动遍历`Generator`函数运行时生成的`Iterator`对象，且此时不需要再调用`next`方法。

```js
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
```

由于`next`方法返回对象的`done`属性为`true`之后，`for...of...`循环就会中止，且不包含返回对象，所以`return`语句返回的`6`不在`for...of...`循环之中。

利用`for...of...`循环，可以写出遍历任意对象（object）的方法。原生的`JavaScript` 对象没有遍历接口，无法使用`for...of...`循环，通过`Generator`函数为它加上这个接口，就可以用了。

```js
function* objectEntries(obj) {
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) {
    yield [propKey, obj[propKey]];
  }
}

let jane = { first: 'Jane', last: 'Doe' };

for (let [key, value] of objectEntries(jane)) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```

另一种写法是将`Generator`函数加到对象的`Symbol.iterator`属性上面。

```js
function* objectEntries() {
  let propKeys = Object.keys(this);

  for (let propKey of propKeys) {
    yield [propKey, this[propKey]];
  }
}

let jane = { first: 'Jane', last: 'Doe' };

jane[Symbol.iterator] = objectEntries;

for (let [key, value] of jane) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```

此外，扩展运算符，`Array.from`都可以将`Generator`函数返回的对象作为参数。

## Generator.prototype.throw()

`Generator`函数返回的遍历器对象，都有一个`throw`方法，可以在函数体外抛出错误，然后在`Generator`函数体内捕获。

```js
var g = function*() {
  try {
    yield;
  } catch (e) {
    console.log('内部捕获', e);
  }
};

var i = g();
i.next();

try {
  i.throw('a');
  i.throw('b');
} catch (e) {
  console.log('外部捕获', e);
}
// 内部捕获 a
// 外部捕获 b
```

遍历器抛出两个错误，第一个错误被`Generator`内部的`catch`捕获，第二次由于`Generator`函数内部的`catch`语句已经执行过了，不会再捕捉这个错误，所以这个错误就被抛出了`Generator`函数体，被函数体外的`catch`语句捕获了。

`throw`可以接收一个参数，该参数会被`catch`语句接收，建议将这个参数写成建议抛出`Error`对象的实例。

`Generator.prototype.throw()`是迭代器自己带的抛出错误的方法，注意和全局的区分。全局的`throw`只能被函数体外的`catch`语句捕获。

如果`Generator`内部没有部署`try...catch...`，那么`throw`方法抛出的错误就会被外部`try...catch...`捕获。而且如果想要内部捕获，必须执行过一次`next`方法。`throw`方法被捕获后，会附带执行一次`next`方法。

一旦`Generator`执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用`next`方法，将返回一个`value`属性等于`undefined`、`done`属性等于`true`的对象，即`JavaScript`引擎认为这个`Generator`已经运行结束了。

## Generator.prototype.return()

`Generator`函数返回的遍历器对象，还有一个`return`方法，可以返回给定的值，并且终结遍历`Generator`函数。

```js
function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

var g = gen();

g.next(); // { value: 1, done: false }
g.return('foo'); // { value: "foo", done: true }
g.next(); // { value: undefined, done: true }
```

调用`return`方法，遍历中止，`done`变为`true`。以后再调用`next`，不会再运行。如果`return`中没有参数，`value`值为`undefined`。

如果`Generator`函数内部有`try...finally`代码块，且正在执行`try`代码块，那么`return`方法会导致立刻进入`finally`代码块，执行完以后，整个函数才会结束。

## next()、throw()、return() 的共同点

本质上都是让`Generator`函数恢复执行，使用不同的语句替换`yield`表达式。

- `next()`将`yield`表达式替换成一个值。
- `throw()`是将`yield`表达式替换成一个`throw`语句。
- `return()`是将`yield`表达式替换成一个`return`语句。

## yield\* 表达式

`ES6`提供了`yield*`表达式，作为解决办法，用来在一个`Generator`函数里面执行另一个`Generator`函数。

```js
function* bar() {
  yield 'x';
  yield* foo();
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  yield 'a';
  yield 'b';
  yield 'y';
}

// 等同于
function* bar() {
  yield 'x';
  for (let v of foo()) {
    yield v;
  }
  yield 'y';
}

for (let v of bar()) {
  console.log(v);
}
// "x"
// "a"
// "b"
// "y"
```

使用`yield*`和`yield + 函数名`的区别在于，前者会返回遍历器对象内的值，后者只会返回一个遍历器对象。`yield*`会自动遍历。

任何数据结构只要有`Iterator`接口，就可以使用`yield*`遍历。

如果`yield*`后面的`Generator`有`return`语句，就可以提供返回值。

## 作为对象属性的 Generator 函数

如果一个对象的属性是`Generator`函数，可以简写为以下形式：

```js
let obj = {
  * myGeneratorMethod() {
    ···
  }
};
// 等同于
let obj = {
  myGeneratorMethod: function* () {
    // ···
  }
};
```

## Generator 函数的 this

`Generator`总是返回一个遍历器，这个遍历器是`Generator`函数的实例，也继承了`Generator`函数的原型对象上的方法。

```js
function* g() {}

g.prototype.hello = function() {
  return 'hi!';
};

let obj = g();

obj instanceof g; // true
obj.hello(); // 'hi!'
```

`Generator`不能当成一个构造函数，也不能使用`new`。

如果想让`Generator`函数返回一个正常的对象实例，又可以用`next`方法，也可以获得正常的`this`。

```js
function* gen() {
  this.a = 1;
  yield (this.b = 2);
  yield (this.c = 3);
}

function F() {
  return gen.call(gen.prototype);
}

var f = new F();

f.next(); // Object {value: 2, done: false}
f.next(); // Object {value: 3, done: false}
f.next(); // Object {value: undefined, done: true}

f.a; // 1
f.b; // 2
f.c; // 3
```

## Generator 与上下文

`JavaScript`代码运行时，会产生一个全局的上下文环境（context，又称运行环境），包含了当前所有的变量和对象。然后，执行函数（或块级代码）的时候，又会在当前上下文环境的上层，产生一个函数运行的上下文，变成当前（active）的上下文，由此形成一个上下文环境的堆栈（context stack）。

`Generator`函数不是这样，它执行产生的上下文环境，一旦遇到`yield`命令，就会暂时退出堆栈，但是并不消失，里面的所有变量和对象会冻结在当前状态。等到对它执行`next`命令时，这个上下文环境又会重新加入调用栈，冻结的变量和对象恢复执行。
