---
title: ES6标准入门-4
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-02-15 20:07:04
visible:
---

# 正则的扩展

## 正则构造函数的变化

在`ES5`中，`RegExp`构造函数的参数有两种情况：

第一种情况是第一个参数是字符串，第二个参数是正则表达式的修饰符：

```JS
var regex = new RegExp('xyz', 'i');
===
var regex = /xyz/i;
```

第二种情况是参数是一个正则表达式，返回一个原有正则表达式的拷贝。

```JS
var regex = new RegExp(/xyz/i);
===
var regex = /xyz/i;
```

`ES5`中不允许第二种情况添加修饰符：

```JS
var regex = new RegExp(/xyz/, 'i'); //会报错
```

但是在`ES6`中，可以在参数是正则对象的情况下，第二个参数传入修饰符。返回的正则表达式会忽略原有正则表达式的修饰符，使用传入的第二个参数作为修饰符。

```js
new RegExp(/abc/gi, 'i').flags;
// "i" ig 被 i 替换了
```

## 字符串的正则方法

字符串对象有四个方法：

- match()
- replace()
- search()
- split()

在`ES6`中调用这四个方法，就相当于调用`RegExp`的实例方法，将这四个方法都定义在了`RegExp`对象上。

- `String.prototype.match`调用`RegExp.prototype[Symbol.match]`
- `String.prototype.replace`调用`RegExp.prototype[Symbol.replace]`
- `String.prototype.search`调用`RegExp.prototype[Symbol.search]`
- `String.prototype.split`调用`RegExp.prototype[Symbol.split]`

## u 修饰符

`ES6`新增了`u`修饰符，用来正确处理大于`0xFFFF`的`Unicode`字符。增加了对四字节编码的支持。

```JS
/^\uD83D/u.test('\uD83D\uDC2A') // false
/^\uD83D/.test('\uD83D\uDC2A') // true
```

由于`ES5`不支持四字节编码，会将其识别为两个字符。所以第二个为`true`。

### . 字符

在正则中，点（`.`）表示匹配除了换行符以外的任意单个字符。对于码点大于`0xFFFF`的无法识别。需要加上`u`才可以识别。

```JS
var s = '𠮷';

/^.$/.test(s) // false
/^.$/u.test(s) // true
```

### Unicode 字符表示法

`ES6`新增了大括号表示`Unicode`字符，需要加上`u`，才能在正则中使用该方法。

```JS
/\u{61}/.test('a') // false
/\u{61}/u.test('a') // true
/\u{20BB7}/u.test('𠮷') // true
```

如果不加`u`，就会被识别为量词，意味着连续匹配多少个连续的`xxx`。

### 量词

使用`u`修饰符，所有的量词都会正确识别`0xFFFF`之上的`Unicode`字符。

```JS
/a{2}/.test('aa') // true
/a{2}/u.test('aa') // true
/𠮷{2}/.test('𠮷𠮷') // false
/𠮷{2}/u.test('𠮷𠮷') // true
```

### 预定义模式

`u`修饰符也影响到预定义模式，预定义模式就是匹配所有非空白啊字符。加上了`u`，就能匹配`0xFFFF`之上的`Unicode`字符。

```JS
/^\S$/.test('𠮷') // false
/^\S$/u.test('𠮷') // true
```

测试字符串长度的函数：

```js
function codePointLength(text) {
  var result = text.match(/[\s\S]/gu); // \s 表示空白 \S 为它的相反
  return result ? result.length : 0;
}

var s = '𠮷𠮷';

s.length; // 4
codePointLength(s); // 2
```

### i 修饰符

`i`修饰符表示不区分大小写，使用`u`，`i`就可以解析`Unicode`中的大小写字母。

```JS
/[a-z]/i.test('\u212A') // false
/[a-z]/iu.test('\u212A') // true
```

### 转义

没有`u`修饰符的情况下，正则中没有定义的转义（如逗号的转义`\,`）无效，而在`u`模式会报错。

```JS
/\,/ // /\,/
/\,/u // 报错
```

## RegExp.prototype.unicode 属性

该属性用来查看正则表达式是否设置了`u`修饰符。

```JS
const r1 = /hello/;
const r2 = /hello/u;

r1.unicode // false
r2.unicode // true
```

## y 修饰符

`y`修饰符叫做粘连修饰符，主要不同的地方在于与`g`修饰符的区别。

`g`和`y`修饰符都表示全局匹配。但是`g`修饰符只要在剩余位置中找到匹配即可，而`y`修饰符必须保证匹配从剩余的第一个位置开始。

```JS
var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
```

也就是说，`y`修饰符相当于在正则中默认增加了`^`，表示匹配头部。这样`^`就可以在全局有效。

如果`y`和`g`连用，并不冲突，在一些正则的方法中，想要找出所有匹配的字符。必须使用`gy`才可以返回。

```JS
const REGEX = /a/gy;
'aaxa'.replace(REGEX, '-') // '--xa'

'a1a2a3'.match(/a\d/y) // ["a1"]
'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"]
```

`y`修饰符的作用在于提取词元（token）的时候发现错误。因为它和`g`都表示全局匹配，正常情况下返回结果是一样的。一旦原字符串中出现了非法字符，使用`y`来提取，就可以很容易发现问题。

```JS
const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;
const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;

tokenize(TOKEN_Y, '3 + 4')
// [ '3', '+', '4' ]
tokenize(TOKEN_G, '3 + 4')
// [ '3', '+', '4' ]
tokenize(TOKEN_Y, '3x + 4')
// [ '3' ]
tokenize(TOKEN_G, '3x + 4')
// [ '3', '+', '4' ]

function tokenize(TOKEN_REGEX, str) {
  let result = [];
  let match;
  while (match = TOKEN_REGEX.exec(str)) {
    result.push(match[1]);
  }
  return result;
}
```

## RegExp.prototype.sticky 属性

该属性可以判断正则实例是否设置了`y`修饰符。

```JS
var r = /hello\d/y;
r.sticky // true
```

## RegExp.prototype.flags 属性

`ES6`新增的该属性返回正则表达式修饰符。

```js
// ES5 的 source 属性
// 返回正则表达式的正文
/abc/gi.source /
  // "abc"

  // ES6 的 flags 属性
  // 返回正则表达式的修饰符
  abc /
  ig.flags;
// 'gi'
```

## s 修饰符 dotAll 模式

正则表达式中`.`表示任意的单个字符，但是有两个例外，一个是四字节的`UTF-16`字符，一个是行终止符。前者可以通过`u`修饰符来解决，后者可以通过`s`修饰符来解决。

以下四个字符属于“行终止符”：

- `U+000A`换行符（\n）
- `U+000D`回车符（\r）
- `U+2028`行分隔符（line separator）
- `U+2029`段分隔符（paragraph separator）

```js
/foo.bar/s.test('foo\nbar'); // true
```

这就是`dotAll`模式，即点代表一切字符。正则也随之增加了一个`dotAll`属性，表示该正则表达式是否处在`dotAll`模式。

```js
const re = /foo.bar/s;
// 另一种写法
// const re = new RegExp('foo.bar', 's');

re.test('foo\nbar'); // true
re.dotAll; // true
re.flags; // 's'
```

`/s`修饰符和多行修饰符`/m`不冲突，两者一起使用的情况下，`.`匹配所有字符，而`^`和`$`匹配每一行的行首和行尾。

## 断言

断言表示一个匹配在某些条件下发生。断言包含先行断言、后行断言和条件表达式。`ES5`只支持先行断言，`ES6`新增了后行断言。

### 先行断言

先行断言就是：`x`只有在`y`前面才匹配，就要写成`/x(?=y)/`。先行否定断言就是反之，`x`只有不在`y`前面才匹配，写成`x(?!y)/`。

这就是规定的语法格式，返回的是匹配的内容，括号中的条件只参与匹配的判断，与返回值内容无关。

```js
/\d+(?=%)/.exec('100% of US presidents have been male')  // ["100"]
/\d+(?!%)/.exec('that’s all 44 of them')                 // ["44"]
```

### 后行断言

后行断言与先行断言的语义相反，`x`只有在`y`后面才匹配，就要写成`/(?<=y)x/`。后行否定断言就是反之，`x`只有不在`y`后面才匹配，写成`(?<!y)x/`。

```js
/(?<=\$)\d+/.exec('Benjamin Franklin is on the $100 bill')  // ["100"]
/(?<!\$)\d+/.exec('it’s is worth about €90')                // ["90"]
```

后行断言不同的地方在于它的匹配是反过来的，先匹配后边的值，再根据前边的条件判断。与其他正则操作相反。

```js
/(?<=(\d+)(\d+))$/.exec('1053') // ["", "1", "053"]
/^(\d+)(\d+)$/.exec('1053') // ["1053", "105", "3"]
```

以上代码表示捕获两个组匹配，正常来说第一个括号是贪婪模式（能匹配多少个就匹配多少个），第二个括号只能匹配一个字符（结尾的）。`1053`是因为`exec`方法数组中第一项会返回匹配的全部字符串，其余项为分组捕获的字符串。

后行断言则相反，第二个括号是贪婪模式，第一个只能匹配一个。

## Unicode 属性类

`ES2018`引入了新的类的写法，允许正则表达式匹配符合`Unicode`某种属性的所有字符。

- \p{...}
- \P{...}：为前者的反向匹配

由于是`Unicode`相关，使用时必须加上`u`修饰符。

使用时需要在大括号中指定属性名和属性值：

```js
\p{UnicodePropertyName=UnicodePropertyValue}
```

这些属性类和属性名`Unicode`中都有定义。

## 具名组匹配

正则表达式使用括号（`()`）来进行组匹配。

```js
const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj[1]; // 1999
const month = matchObj[2]; // 12
const day = matchObj[3]; // 31
```

![](111.jpg)

使用`exec`方法来提取组匹配结果，但是这样的局限性在于每一组的匹配含义不容易看出来。顺序变了对应的序号就得变化。

`ES2018`增加了具名组匹配，允许为每一个组指定一个名字。通过名字来访问具体匹配结果。

具体语法就是在之前的组匹配前加上`?<组名>`。

```js
const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;

const matchObj = RE_DATE.exec('1999-12-31');
const year = matchObj.groups.year; // 1999
const month = matchObj.groups.month; // 12
const day = matchObj.groups.day; // 31
```

![](222.jpg)

可见使用了具名组匹配后，对应的变量和值保存在结果的`groups`对象属性中。如果顺序变了，也无需改变代码。相当于为每一组匹配加上了`ID`。

如果具名组没有匹配，那么对应的`groups`对象属性值为`undefined`。但是键名依然存在。

![](333.jpg)

### 解构赋值和替换

有了具名组匹配之后，可以使用解构赋值直接从匹配结果为变量赋值。

```js
let {
  groups: { one, two }
} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');
one; // foo
two; // bar
```

字符串替换，使用`${组名}`引用具名组：

```js
let re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/u;

'2015-01-02'.replace(re, '$<day>/$<month>/$<year>'); // '02/01/2015'
```

`replace`方法第二个参数可以是字符串，也可以是函数。使用了具名组匹配，新增了`groups`参数。可以直接解构赋值。

```js
'2015-01-02'.replace(
  re,
  (
    matched, // 整个匹配结果 2015-01-02
    capture1, // 第一个组匹配 2015
    capture2, // 第二个组匹配 01
    capture3, // 第三个组匹配 02
    position, // 匹配开始的位置 0
    S, // 原字符串 2015-01-02
    groups // 具名组构成的一个对象 {year, month, day}
  ) => {
    let { day, month, year } = groups;
    return `${day}/${month}/${year}`;
  }
);
```

### 引用

如果要在正则表达式内部引用某个具名组匹配，可使用`\k<组名>`的方式，也可以采用`\1`的写法。

```js
const RE_TWICE = /^(?<word>[a-z]+)!\k<word>$/;
RE_TWICE.test('abc!abc'); // true
RE_TWICE.test('abc!ab'); // false

const RE_TWICE = /^(?<word>[a-z]+)!\1$/;
RE_TWICE.test('abc!abc'); // true
RE_TWICE.test('abc!ab'); // false

const RE_TWICE = /^(?<word>[a-z]+)!\k<word>!\1$/;
RE_TWICE.test('abc!abc!abc'); // true
RE_TWICE.test('abc!abc!ab'); // false
```

## 正则匹配索引

正则匹配结果的开始和结束位置获取不是很方便，使用`exec`也只会返回一个整个结果开始的位置。如果包含组匹配则很难直接拿到。

有一个第三阶段的提案，为`exec()`方法新增了一个`indices`属性，该属性中存储了匹配的开始和结束位置。

```js
const text = 'zabbcdef';
const re = /ab/;
const result = re.exec(text);

result.index; // 1
result.indices; // [ [1, 3] ]
```

位置属于左闭右开取件，左边为开始下标，右边为结束的下一个下标。如果包含组匹配，该属性中也会包含多个数组成员分别存储。第一个成员总是整个匹配结果返回的下标，之后才是组匹配的下标。

```js
const text = 'zabbcdef';
const re = /ab+(cd)/;
const result = re.exec(text);

result.indices; // [ [ 1, 6 ], [ 4, 6 ] ]
```

如果正则中包含具名组匹配，`indices`还会包含一个`groups`对象属性，由组名作为属性，下标作为值。

```js
const text = 'zabbcdef';
const re = /ab+(?<Z>cd)/;
const result = re.exec(text);

result.indices.groups; // { Z: [ 4, 6 ] }
```

如果匹配失败，对应的值为`undefined`：

```js
const text = 'zabbcdef';
const re = /ab+(?<Z>ce)?/;
const result = re.exec(text);

result.indices[1]; // undefined
result.indices.groups['Z']; // undefined
```

## String.prototype.matchAll()

如果一个字符串有多个符合正则表达式的匹配，使用`g`或`y`操作符匹配。再将结果通过循环取出：

```js
var regex = /t(e)(st(\d?))/g;
var string = 'test1test2test3';

var matches = [];
var match;
while ((match = regex.exec(string))) {
  matches.push(match);
}
```

在`ES2020`新增了`String.prototype.matchAll()`方法，可以一次性取出所有匹配。但是它返回的是一个遍历器，不是数组。

```js
const string = 'test1test2test3';

// g 修饰符加不加都可以
const regex = /t(e)(st(\d?))/g;

for (const match of string.matchAll(regex)) {
  console.log(match);
}
// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]
// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]
// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]
```

优点在于数据量大时比较节省资源，也可以将遍历器转为数组：

```js
// 转为数组方法一
[...string.matchAll(regex)];

// 转为数组方法二
Array.from(string.matchAll(regex));
```
