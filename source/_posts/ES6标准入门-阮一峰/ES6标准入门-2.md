---
title: ES6标准入门-2
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-02-11 13:36:47
visible:
---

# 变量的解构赋值

`ES6`允许按照一定模式从一些数据结构中提取值，然后对变量进行赋值，这就是解构赋值。解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）。

## 数组的解构赋值

### 基本用法

```JavaScript
let [a, b, c] = [1, 2, 3]
```

本质上属于模式匹配，只要等号两边的模式相等，就可以按照对应的位置对变量赋值。

如果解构不成功，变量的值就会返回`undefined`。如果等号右边不是可遍历的结构，就会报错。

对于`Set`结构，也可以进行解构。所以能否解构完全取决于等号右边的数组是否有`Iterator`（遍历器）接口。`Generator`函数也可以。

![](111.jpg)

#### 完全解构

以下情况属于完全解构，就是变量和要解构的值刚好可以对应。

```JavaScript
let [foo, [[bar], baz]] = [1, [[2], 3]]
let [ , , c] = [1, 2, 3] // c: 3
let [a, ...b] = [1, 2, 3] // a: 1, b: [2,3]
```

#### 不完全解构

等号左边的模式只能匹配部分等号右边的数组。解构依然可以成功。

```JavaScript
let [a, b] = [1, 2, 3]; // a: 1 b: 2
```

### 默认值

解构赋值可以指定默认值。如果被解构的数据结构内部的值严格相等（`===`）于`undefined`，才会使用默认值。

```JavaScript
let [a = 1, b = 2] = [undefined, 3] // a: 1, b: 2
let [a = 1, b = 2] = [] // a: 1, b: 2
```

如果默认值是一个表达式，那么这个表达式是惰性求值的，也就是只有用到的时候才会将这个表达式求值。

```JavaScript
function f() {
  return 3;
}
let [a = f()] = [1] // a: 1
```

函数`f()`根本不会执行，只有解构失败才会取默认值执行。

默认值可以引用解构赋值的其他变量，但必须是已经声明的变量。因为解构赋值也是一种声明变量的方式嘛。

```JavaScript
let [x = 1, y = x] = [] // x :1, y: 1
```

## 对象的解构赋值

解构赋值也可以用于对象，与数组解构赋值最大的差别是数组是按照元素的索引来匹配值，而对象的属性没有次序，变量必须与属性同名才可以取到正确的值。取值失败同样返回`undefined`。

```JavaScript
let {a, b} = {a: 1, b: 2} // a: 1, b: 2
let {b, a} = {a: 1, b: 2} // a: 1, b: 2
```

可见对象的解构赋值与声明变量的顺序是没有任何关系的。

### 对象解构赋值的原理

如果变量名和属性名不一致，必须写成如下这样：

```JavaScript
let {a: c, b: d} = {a: 4, b: 5} // c: 4, d: 5
// a 和 b 都会显示未声明
```

这说明了对象的解构赋值是对下面代码的简写：

```JavaScript
let {a: a, b: b} = = {a: 4, b: 5}
```

上方写法可行的原因是因为`ES6`允许在对象中只写属性名，不写属性值。这时属性值等于属性名所代表的变量。

也就是说，对象的解构赋值内部机制是先找到同名的属性，再赋值给对应的变量，真正被赋值的是后者（属性值），而不是前者（属性名）。

这也就解释了本节第一行代码为什么`a`和`b`会显示为未声明。因为`a`和`b`是匹配的模式，`c`和`d`才是真正被赋值的的变量。

### 对象解构赋值其他用法

对象解构赋值也可以用于嵌套结构的对象：

![](222.jpg)

可以看出，如果要对嵌套的对象进行解构，一定要区分模式和变量。`a1`就是模式，不会被声明和赋值。如果要对`a1`进行赋值的话，需要这样写：

```JavaScript
let {
  a,
  a1,
  a1: { b, c }
} = target;
```

也可以进行嵌套赋值：

![](333.jpg)

对象的解构也可以指定默认值，当对象的属性严格等于`undefined`时使用默认值。

如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，就会报错。

```JavaScript
let {
  foo: { bar }
} = { a: 1 };
```

这个是肯定的，因为`udnefined`不可能有属性。

解构赋值允许等号左边的模式之中不放任何变量名称，虽然这样写出的表达式没任何意义，但是不报错。

```JavaScript
({} = [true, false])
({} = 'abc')
```

使用括号包裹起来的原因是让编译器认为这是一个表达式，而不是函数语句。

## 字符串的解构赋值

字符串也可以解构赋值，因为在此时字符串会被转为一个类似数组的对象。

```JavaScript
const [a, b, c, d, e] = '12345';
console.log(a, b, c, d, e); // 1 2 3 4 5
```

类数组都有一个`length`属性，可以根据该属性进行对象解构：

```JavaScript
let { length } = '12345';
console.log(length); // 5
```

## 数值和布尔值的解构赋值

对这两种类型的值进行解构赋值时，会对以上两者先转为对象，再进行解构赋值。

```JavaScript
let { toString } = '123';

console.log(toString); // [Function: toString]
```

规则就是如果等号右边的值不是对象或者数组，就先将其转为对象。`undefined`和`null`无法转为对象，所以对他们进行解构赋值会报错。

## 函数参数的解构赋值

函数的参数也可以进行解构赋值：

```JavaScript
function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
```

也可以给解构的属性默认值：

```JavaScript
function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
```

很好理解，`JavaScript`对象中，如果对应的属性没有，就会将该属性指为`undefined`。额外增加的一点是在添加了解构赋值的默认值之后，可以如同`move()`一样传入一个空，这样函数会自己查找至少一个被提供的参数。

```JavaScript
function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
```

这段代码对函数的参数使用了解构赋值，但是没有给解构赋值的变量默认值。而是给了函数参数默认值。

函数参数默认值是针对于整个参数整体的，函数默认参数允许在没有值或`undefined`被传入时使用默认形参。因为参数就是一个对象（就一个参数），所以只有当该对象不存在或者是`undefined`，才会触发默认值语句。

以上两个代码块，前者更像是后者的进阶版，对传了参，但是参数中没有值的部分有了更细密的处理。

## 圆括号问题

解构赋值解析起来并不容易，对于编译器来说，只有解析到等号才能知道一个式子到底是模式还是表达式。

如果在模式中出现圆括号怎么处理是一个显而易见的问题，`ES6`规定只要有可能导致解构带来的歧义，就不能使用圆括号。换句话说，禁止在模式中使用圆括号。

### 不能使用圆括号的情况

#### 变量声明语句

```JavaScript
// 全部报错
let [(a)] = [1];

let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};

let { o: ({ p: p }) } = { o: { p: 2 } };
```

#### 函数参数

函数参数也属于变量声明。

```JavaScript
// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
```

#### 赋值语句的模式

将模式部分或全部放在圆括号之中都会报错。模式部分就是左边的那个不被赋值的用来匹配的部分。

```JavaScript
// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];

// 报错
[({ p: a }), { x: c }] = [{}, {}];
```

### 可以使用圆括号的情况

只有一种，就是赋值语句的非模式部分。

```JavaScript
[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
```

## 用途

### 快速交换变量的值

语义清晰，写法简介，易读性高。

```JavaScript
let x = 1;
let y = 2;

[x, y] = [y, x]
```

### 从函数返回多个值

函数只能返回一个值，不能`return a, b, c`，只能将它们放在对象中返回。可以使用解构赋值快速取出这些值。

```JavaScript
function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();
```

### 函数参数的定义

解构赋值可以方便地将一组参数与变量名对应起来

```JavaScript
// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
```

### 提取 JSON 数据

因为`JSON`字符串转过来也是对象嘛，也可以直接进行解构赋值。

```JavaScript
let jsonData = {
  id: 42,
  status: "OK",
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, "OK", [867, 5309]
```

### 函数参数的默认值

首先有了默认值，函数的可读性就高了，其次避免在函数体内部定义一些对逻辑没什么用的语句。

```JavaScript
jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
```

### 遍历 Map 结构

部署了`Iterator`接口的对象，都可以使用`for...of...`来遍历。配合`ES6`的**属性名表达式**，就可以快读获取键名和键值。

```JavaScript
const map = new Map();
map.set('first', 'hello');
map.set('second', 'world');

for (let [key, value] of map) {
  console.log(key + " is " + value);
}
// first is hello
// second is world
```

如果只想获取键名或键值，可以使用`[key]`或`[,value]`来进行遍历。

### 输入模块的指定方法

加载模块时往往需要指定输入的方法，使用解构赋值，可以更加清晰快捷的指定。

```JavaScript
const { SourceMapConsumer, SourceNode } = require("source-map");
```
