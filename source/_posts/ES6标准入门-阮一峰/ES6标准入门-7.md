---
title: ES6标准入门-7
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-02-28 14:53:03
visible:
---

# 数组的扩展

## 扩展运算符

扩展运算符（spread）是三个点，用来将一个数组转为用逗号分隔的参数序列。

```js
console.log(...[1, 2, 3]);
// 1 2 3

console.log(1, ...[2, 3, 4], 5);
// 1 2 3 4 5
```

在函数调用时，可以使用该运算符将参数打散，传入方法或函数中。也只有在函数的括号中，才可以放置扩展运算符。

```js
function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers); // 42
```

扩展运算符后面是一个空数组则不起作用，后面还可以放一个表达式。

![](111.jpg)

### 替代函数的 apply 方法

扩展运算符可以展开数组，这样就可以替代`apply`，直接将数组转为函数的参数。

```js
// ES5 的写法
Math.max.apply(null, [14, 3, 77]);

// ES6 的写法
Math.max(...[14, 3, 77]);

// 等同于
Math.max(14, 3, 77);
```

### 应用

#### 复制数组

数组是复合的数据类型，直接复制会只复制指针，而不是克隆一个新的数组。

```js
const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
```

#### 合并数组

```js
const arr1 = ['a', 'b'];
const arr2 = ['c'];
const arr3 = ['d', 'e'];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3];
// [ 'a', 'b', 'c', 'd', 'e' ]
```

这两种方法都是浅拷贝，修改引用指向的值，会同步反映到合并后的新数组。

#### 与解构赋值结合

扩展运算符可以与解构赋值结合起来，用于生成新数组，只能放在参数最后一位，否则会报错。

```js
// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
```

#### 将字符串转为真正的数组

优点在于可以识别四字节`Unicode`字符。

```js
[...'hello']
// [ "h", "e", "l", "l", "o" ]

'x\uD83D\uDE80y'.length // 4
[...'x\uD83D\uDE80y'].length // 3
```

#### 实现了 Iterator 接口的对象

任何定义了`Iterator`接口的对象，都可以用扩展运算符转为真正的数组。

```js
let nodeList = document.querySelectorAll('div');
let array = [...nodeList];
```

前提在于对象要定义遍历器接口：

```js
Number.prototype[Symbol.iterator] = function*() {
  let i = 0;
  let num = this.valueOf();
  while (i < num) {
    yield i++;
  }
};

console.log([...5]); // [0, 1, 2, 3, 4]
```

## Array.from()

`Array.from`用于将类数组和遍历的对象转为真正的数组（浅拷贝），也可以传入字符串（字符串也是类数组），可以正确处理各种`Unicode`字符。

该方法接收三个参数，类数组或可迭代对象，回调函数，`this`对象。返回一个新的数组实例。

```js
const someNumbers = { '0': 10, '1': 15, length: 2 };

Array.from(someNumbers, value => value * 2); // => [20, 30]
```

### 克隆一个数组

```js
const numbers = [3, 6, 9];
const numbersCopy = Array.from(numbers);

numbers === numbersCopy; // => false
```

使用该方法可以实现对数组的浅拷贝。

```js
function recursiveClone(val) {
  return Array.isArray(val) ? Array.from(val, recursiveClone) : val;
}

const numbers = [
  [0, 1, 2],
  ['one', 'two', 'three']
];
const numbersClone = recursiveClone(numbers);

numbersClone; // => [[0, 1, 2], ['one', 'two', 'three']]
numbers[0] === numbersClone[0]; // => false
```

也可以实现数组的深拷贝。

### 使用值来填充数组

```js
const length = 3;
const init = 0;
const result = Array.from({ length }, () => init);

result; // => [0, 0, 0]
```

### 生成数字范围

使用该方法生成指定范围内的值填充的数组。

```js
function range(end) {
  return Array.from({ length: end }, (_, index) => index);
}

range(4); // => [0, 1, 2, 3]
```

### 数组去重

```js
function unique(array) {
  return Array.from(new Set(array));
}

unique([1, 1, 2, 3, 3]); // => [1, 2, 3]
```

## Array.of()

`Array.of()`用于将一组值转换为数组。

```js
Array.of(3, 11, 8); // [3,11,8]
Array.of(3); // [3]
Array.of(3).length; // 1
```

这个方法的主要目的是弥补数组构造函数`Array`的不足。参数的个数会导致`Array()`的行为有差异。

```js
Array(); // []
Array(3); // [, , ,]
Array(3, 11, 8); // [3, 11, 8]
```

`Array`和`new Array`完全一致，可以使用`Array.of()`来替代，总是返回参数值组成的数组，如果没有参数，则返回一个空数组。

`ES5`实现：

```js
function ArrayOf() {
  return [].slice.call(arguments);
}
```

## 数组实例的 copyWithin()

该方法会在当前数组内部，将指定成员复制到其他位置，会覆盖原有成员，并返回当前数组（会修改当前数组）。

```js
Array.prototype.copyWithin(target, (start = 0), (end = this.length));
```

- target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
- start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
- end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

三个参数默认是数值，如果不是会自动转换为数值。

```js
[1, 2, 3, 4, 5].copyWithin(0, 3);
// [4, 5, 3, 4, 5]
```

## 数组实例的 find() 和 findIndex()

`find()`方法返回第一个符合条件的数组成员，第一个参数是一个回调函数，返回回调函数为`true`的成员，第三个参数是`this`对象，指定该方法运行环境。如果没有符合条件的成员，返回`undefined`。

```js
[1, 4, -5, 10].find(n => n < 0);
// -5
```

`findIndex`方法返回第一个复合条件的数组成员的位置，如果所有成员都不符合，返回`-1`。

```js
[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value > 9;
}); // 2
```

```js
function f(v) {
  return v > this.age;
}
let person = { name: 'John', age: 20 };
[10, 12, 26, 15].find(f, person); // 26
```

这两个方法新增的目的在于都可以发现`NaN`，弥补了`indexOf`的不足。

```js
[NaN]
  .indexOf(NaN)
  // -1

  [NaN].findIndex(y => Object.is(NaN, y));
// 0
```

因为判断依据是回调函数返回值嘛，自然可以支持。

## 数组实例的 fill() 方法

`fill`方法使用给定的值，填充一个数组，会将原数组中元素全部抹去。

```js
['a', 'b', 'c'].fill(7);
// [7, 7, 7]

new Array(3).fill(7);
// [7, 7, 7]
```

还可以接受第二个和第三个参数，用于指定起始位置和结束位置。

```js
['a', 'b', 'c'].fill(7, 1, 2);
// ['a', 7, 'c']
// 从第一位开始，二号位之前结束，左闭右开
```

如果填充的是一个对象，那么将是以赋值的方式填充。而不是深拷贝对象。

```js
let arr = new Array(3).fill({ name: 'Mike' });
arr[0].name = 'Ben';
arr;
// [{name: "Ben"}, {name: "Ben"}, {name: "Ben"}]

let arr = new Array(3).fill([]);
arr[0].push(5);
arr;
// [[5], [5], [5]]
```

## 数组实例的 entries()，keys() 和 values()

`ES6`新增的三个新方法来遍历数组，返回一个遍历器对象，可使用`for...of...`进行遍历：

- entries()：对键值对的遍历
- keys()：对键名遍历
- values()：对键值得遍历

```js
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

也可以手动调用遍历器的`next`方法进行遍历：

```js
let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']
```

## 数组实例的 includes()

返回一个布尔值，用于表示某个数组是否包含指定的值，与字符串同名方法类似。第一个参数表示要查找的值，第二个参数表示搜索的起始位置，如果是负值或者大于数组长度，则从`0`开始，相当于没传。同时该方法解决了`indexOf`方法无法判断`NaN`的缺陷。

```js
[1, 2, 3].includes(3, 3); // false
[1, 2, 3].includes(3, -1); // true
```

## flat()，flatMap()

数组的成员有时候还是数组，`flat()`可以将数组拉平，变为一维数组，同时返回一个新数组，对原数组没有影响。

```js
[1, 2, [3, 4]].flat();
// [1, 2, 3, 4]
```

默认只能拉平一层，想拉平多层需要传入一个整数，表示想拉平的层数。

```js
[1, 2, [3, [4, 5]]].flat()[
  // [1, 2, 3, [4, 5]]

  (1, 2, [3, [4, 5]])
].flat(2);
// [1, 2, 3, 4, 5]
```

如果不管多少层都想拉平，可以使用`Infinity`关键字作为参数：

```js
[1, [2, [3]]].flat(Infinity)
// [1, 2, 3]
[1, 2, , 4, 5].flat()
// [1, 2, 4, 5] 有空位会跳过
```

`flatMap`对数组中每个成员执行一个`map`方法，之后再执行`flat()`方法，返回一个新数组。该方法只能拉平一层。该方法接受两个参数，第一个是回调函数，函数中有三个参数（元素，下标，原数组），第二个是`this`对象，指定第一个参数中的`this`。

```js
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap(x => [x, x * 2]);
// [2, 4, 3, 6, 4, 8]
```

## 数组的空位

数组的空位不是`undefined`，而是数组某个位置没有任何值，使用`in`运算符来说明这一点。

```js
Array(3); // [, , ,]

0 in [undefined, undefined, undefined]; // true
0 in [, , ,]; // false
```

`ES6`不同之处在于对空位的处理上，在`ES5`中，各种方法对空位的处理很不一致：

> `forEach()`,`filter()`,`reduce()`,`every()`和`some()`都会跳过空位。
> `map()`会跳过空位，但会保留这个值
> `join()`和`toString()`会将空位视为`undefined`，而`undefined`和`null`会被处理成空字符串。

`ES6`明确将数组的空位转为`undefined`。以上提到的所有`ES6`数组新增方法，如果涉及遍历，都会遍历空位，其他对象转为数组会将空位转为`undefined`，拷贝也会连空位一起拷贝。

## Array.prototype.sort() 的排序稳定性

> 排序的稳定性：保证排序前两个相等的数在序列中的前后顺序，和排序后相同

`ES2019`明确规定，`Array.prototype.sort()`的默认排序算法必须稳定。这个规定已经做到了，现在`JavaScript`各个主要实现的默认排序算法都是稳定的。
