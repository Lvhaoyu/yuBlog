---
title: ES6标准入门-1
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-02-03 19:39:24
visible:
---

# let 和 const 命令

在`ES6`之前，使用`var`声明变量会导致很多情况不合理，也会产生很多莫名其妙的`bug`。大多原因是由于`JavaScript`没有块作用域，只有全局作用域和函数作用域。

## let 命令

### 基本用法

`let`的基本使用类似于`var`，用来声明一个**可以修改**变量。

### 不存在变量提升

使用`var`声明变量会发生变量提升（变量可以在声明那行代码之前使用），但是值为`undefined`。不使用`var`来声明会声明一个全局变量。

`let`修改了这个语法行为，声明的变量只能在声明后使用。

### 暂时性死区

只要块级作用域内存在`let`命令，它声明的变量就绑定在这个区域，不受外部的影响。这种性质被称为“暂时性死区”。

具体到例子如下：

```JavaScript
var tmp =1;
if(true) {
  tmp = 2; // VM193:3 Uncaught ReferenceError
  let tmp;
}
```

如果在一个块级作用域使用`let`或`const`命令声明变量，那这个变量就和其他作用域没关系了。就算外层作用域声明了该变量，在块级作用域中也不能在`let`或`const`命令声明变量之前使用。

在进入作用域创建变量，到变量开始可被访问之间的一段时间，就称之为`TDZ`(暂时死区)。

暂时性死区是只要进入当前作用域，所要使用的变量就已经存在，但是不能用，只有声明变量的代码存在后，才能获取和使用变量。

可以将暂时性死区和变量提升结合起来，正是因为暂时性死区，才有了不存在变量提升这个性质。因为使用`let`和`const`声明的变量在当前块内也是会先在作用域中被创建出来了，但因此时还未进行词法绑定，也就是对声明语句进行求值运算，所以是不能被访问的，访问就会抛出错误。

`let`和`const`声明的变量，的确也是有提升(hoist)的作用。提升是`JS`中对于变量声明的基本特性，只是因为`TDZ`的作用，并不会像使用`var`来声明变量那样得到`undefined`，而是会直接抛出`ReferenceError`错误，这是一个在运行期间才会出现的错误。

此外，该特性会导致`typeof`出错，之前使用该操作符查看一个未声明变量会返回`undefined`。如今在块级作用域使用`let`或`const`声明之前使用该运算符查看变量就会报错。

### 不允许重复声明

`let`不允许在相同作用域内声明同一个变量。也不能在函数内部重新声明参数，除非在函数中再嵌套一个块级作用域。

![](444.jpg)

## 块级作用域

### 什么是作用域

- 广义：可访问变量、函数、对象的集合，决定代码区域中变量和其他资源的可见性。

- 狭义：所有编程语言最基本的功能就是存储变量的的值，并且在之后能够访问和修改它，这种访问或者修改变量的值的能力给程序带来了“状态”，如果没有状态，程序的灵活性会大大降低，在程序中如何存储变量，对已存储变量的访问，需要一套设计良好的规则，我们称这套规则为作用域。

### 什么是块级作用域

在`ES6`中，块级作用域就是包含在`{...}`中配合`let`和`const`使用的作用域，有着和函数作用域相同的行为。

早在`ES5`，就可以使用`try/catch`语法和`with`（基本没人用）来创建块级作用域。到了`ES6`，就可以使用`let`和`const`将变量绑定在当前作用域内。

### 块级作用域有啥用

为什么会有块级作用域呢？就是因为在`ES5`的时候，只有全局作用域和函数作用域。一不小心就容易创建全局变量。全局变量大家都知道，是很不安全的，万一哪天声明了一个一样的变量将之前的覆盖，程序就报错了。其次就是在变量声明提升的作用下，会导致内层变量覆盖外层变量。最后就是`for`循环中计数的变量使用结束后会被泄露成全局变量。

### ES6 中的块级作用域

前边说过，`let`和`const`命令会生成块级作用域。相当于`let`和`const`将其所在的作用域劫持了（这块地我占了，谁都别想出去）。

`ES6`允许作用域内部任意的嵌套。内层可以访问外层，但是外层无法读取内层。

```JavaScript
{{{{{{let a = 1}}}}}}
```

所以立即执行匿名函数就不需要了。

### 块级作用域与函数声明

`ES5`规定不能在块级作用域中声名函数。在`ES6`中，就可以在块级作用域（`{...}`）声明函数了，相当于使用`let`声明变量的行为。注意，只有使用`function (){...}`声明的函数才会有这种行为。使用函数表达式声明函数与此无关。

可是浏览器并没有按照规范来，为了兼容老代码，前者也可以正常使用。后者将行为改成了与使用`var`声明的行为一致，会提升到块级作用域的顶部。在函数作用域也提升到函数作用域的顶部。全局作用域中声明的函数也是如此。除了浏览器环境，其他的都按规范来。

![](111.jpg)

在块级作用域中声明函数的规则只允许在使用大括号的情况下成立，如果省略了大括号，就会报错。

```JavaScript
'use strict'
if(true)
  function f() {} // 报错
```

![](222.jpg)

## const 命令

`const`声明一个只读的常量。一旦声明，常量的值就不能改变，因此在声明时就必须给变量赋值。

作用域与`let`相同，同一作用域内不可重复声明，也存在暂时性死区，声明的变量也不会提升。

### const 本质

`const`保证的是变量指向的内存地址不可以改动。对于简单的数据类型（数字，字符串，布尔值）来说，值就存在变量指向的内存地址中，等同于常量。但是对于复合类型的数据（对象和数组）而言，变量指向的内存地址保存的是一个指针。所以`const`声明数组和对象，他们的属性是可以修改的。

如果想让对象不可修改，可以使用`Object.freeze()`方法。在常规模式下使用该方法冻结对象后，修改对象属性不起作用，严格模式下会报错。

如果对象中还有对象，也可以实现递归函数将对象的属性冻结。

```JavaScript
cosnt freezeAll = (obj) => {
  Object.keys(obj).forEach((key, i)=>{
    if(typeof(obj[key]) === "object") {
      freezeAll(obj[key]);
    }
  })
}
```

## ES6 声明变量的 6 种方法

- var
- function
- let
- const
- import
- class

## 顶层对象的属性

在运行`JS`的环境中，有两种顶层对象。第一种是在浏览器中的`window`对象，第二种是在`Node`环境中的`global`对象。在`ES5`中，顶层对象的属性和全局变量是等价的。

顶层对象和全局变量相关，这个有很大的问题：

- 编译时无法提示变量未声明，运行时才可以知道
- 程序员不小心可以轻易地创建全局变量
- 顶层对象属性到处都可以读写，不利于模块化编程
- `window`对象有实体含义，指的是浏览器窗口对象，容易给人造成误解

到了`ES6`，为了保持兼容性，使用`var`和`function`创建的全局变量仍然等价于顶层对象的属性。使用`let`，`const`，`class`声明的全局变量不属于顶层对象的属性。

## global 对象

因为在不同的环境中`JS`有不同的运行时。浏览器中顶层是`window`，`self`也指向顶层。`Web Worker`中`self`指向顶层。`Node`中顶层对象是`global`，不存在`self`和`window`。

同一段代码要想在所有环境都能取到顶层对象，可以借助`this`来实现。局限性有以下几点：

- 全局环境，`this`返回顶层对象。在`Node`或`ES6`模块中，`this`返回当前模块。
- 对于函数中的`this`，如果函数单纯的作为函数运行（没有作为对象的方法），会指向顶层对象。但是严格模式会返回`undefined`。
- 使用`new Function('return this')()`总会返回全局对象。但是如果浏览器使用了`CSP`（内容安全政策）,该方法不可用。

不过如今环境中引入了`globalThis`作为全局对象（提案时是`global`，后来改成这个名字），也无需担心这些问题。

![](333.jpg)

如果要在未支持该特性的浏览器寻找顶层对象，可以使用下面两种方法。

```JavaScript
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
```
