---
title: ES6标准入门-13
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-03-03 16:39:31
visible:
---

# Iterator 和 for...of... 循环

## Iterator 的背景

`Iterator`是遍历器的意思，`JS`原有的表示“集合”的数据接口就是数组和对象，`ES6`新增了`Map`和`Set`，这样就有了四种数据集合，用户可以组合使用他们来定义自己的数据结构。这样就需要一种统一的接口机制，来处理所有不同的数据结构。

遍历器就是为各种不同的数据结构提供统一的访问机制而生的，任何数据结构只要部署`Iterator`接口，就可以完成遍历操作。

## Iterator 的用法

`Iterator`接口有三个作用：

- 为各种数据结构提供统一的，简便的访问接口。
- 使数据结构的成员能够按照某种次序排列
- 和`ES6`新命令`for...of...`配合使用

`Iterator`接口遍历过程如下：

1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。

2. 第一次调用指针对象的`next`方法，可以将指针指向数据结构的第一个成员。

3. 第二次调用指针对象的`next`方法，指针就指向数据结构的第二个成员。

4. 不断调用指针对象的`next`方法，直到它指向数据结构的结束位置。

每一次调用`next`方法，都会返回数据接口当前成员的信息。就是返回如下形式的对象：

```js
{ value: "a", done: false }
```

## 默认 Iterator 接口

一个数据结构只要部署了`Iterator`接口，就称这种数据结构为可遍历的。

`ES6`规定，默认的`Iterator`接口部署在数据结构的`Symbol.iterator`属性上，只要一个数据结构有`Symbol.iterator`属性，就可以认为这个数据结构是可遍历的。

`Symbol.iterator`属性值本身是一个遍历器生成函数，只要执行这个函数，就会返回一个遍历器。`Symbol.iterator`属性名作为一个预定义好的`Symbol`类型，需要放在方括号内。

```js
const obj = {
  [Symbol.iterator]: function() {
    return {
      next: function() {
        return {
          value: 1,
          done: true
        };
      }
    };
  }
};
```

以上就是一个已经部署了`Iterator`接口的对象。在广义上已经符合了`Iterator`接口的概念。

`ES6`有几个对象已经默认原生自带了`Iterator`接口，称为部署了遍历器接口。

- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象

可以使用下面的代码手动调用这些对象的遍历器方法：

```js
let arr = ['a', 'b', 'c'];
let iter = arr[Symbol.iterator]();

iter.next(); // { value: 'a', done: false }
iter.next(); // { value: 'b', done: false }
iter.next(); // { value: 'c', done: false }
iter.next(); // { value: undefined, done: true }
```

对象（Object）之所以没有部署遍历器接口是因为对象的属性遍历顺序是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作`Map`结构使用，`ES5`没有`Map`结构，而`ES6`原生提供了。

一个对象如果要具备可被`for...of...`循环调用的`Iterator`接口，就必须在`Symbol.iterator`的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。

## 为对象实现遍历器接口

```js
let obj = {
  data: ['hello', 'world'],
  [Symbol.iterator]() {
    const self = this;
    let index = 0;
    return {
      next() {
        if (index < self.data.length) {
          return {
            value: self.data[index++],
            done: false
          };
        } else {
          return { value: undefined, done: true };
        }
      }
    };
  }
};

function* entries(obj) {
  for (let key of Object.keys(obj)) {
    yield [key, obj[key]];
  }
}

for (let [key, value] of entries(obj)) {
  console.log(key, '->', value);
}
// a -> 1
// b -> 2
// c -> 3
```

总结一下就是首先给对象增加`Symbol.iterator`属性，之后在该属性方法内实现`next`方法。最后返回`{ value: undefined, done: true }`形式的对象。如果`Symbol.iterator`方法对应的如果不是遍历器生成函数，那么就会报错。有了遍历器接口，就可以实现`for...of...`和`while`遍历。

当然也可以使用第二种`Generator`函数最简单的实现方法。

```js
var $iterator = ITERABLE[Symbol.iterator]();
var $result = $iterator.next();
while (!$result.done) {
  var x = $result.value;
  // ...
  $result = $iterator.next();
}
```

## 调用 Iterator 接口的场合

### 解构赋值

对数组和`Set`进行解构赋值时会默认调用`Symbol.iterator`方法。

```js
let set = new Set()
  .add('a')
  .add('b')
  .add('c');

let [x, y] = set;
// x='a'; y='b'

let [first, ...rest] = set;
// first='a'; rest=['b','c'];
```

### 扩展运算符

```js
// 例一
var str = 'hello';
[...str]; //  ['h','e','l','l','o']

// 例二
let arr = ['b', 'c'];
['a', ...arr, 'd'];
// ['a', 'b', 'c', 'd']
```

任何部署了`iterator`接口的数组接口，都能以`[...obj]`的方式来转为数组。

### yield\*

`yield*`后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。

```js
let generator = function*() {
  yield 1;
  yield* [2, 3, 4];
  yield 5;
};

var iterator = generator();

iterator.next(); // { value: 1, done: false }
iterator.next(); // { value: 2, done: false }
iterator.next(); // { value: 3, done: false }
iterator.next(); // { value: 4, done: false }
iterator.next(); // { value: 5, done: false }
iterator.next(); // { value: undefined, done: true }
```

### 其他场合

- for...of...
- Array.from()
- Map(), Set(), WeakMap(), WeakSet()（比如`new Map([['a',1],['b',2]])`）
- Promise.all()
- Promise.race()

## Iterator 接口与 Generator 函数

这是遍历器接口方法的最简单实现，只要使用`yield`命令给出每一步的返回值即可。

```js
let myIterable = {
  [Symbol.iterator]: function* () {
    yield 1;
    yield 2;
    yield 3;
  }
}
[...myIterable] // [1, 2, 3]

// 或者采用下面的简洁写法

let obj = {
  * [Symbol.iterator]() {
    yield 'hello';
    yield 'world';
  }
};

for (let x of obj) {
  console.log(x);
}
// "hello"
// "world"
```

## 遍历器对象的 return()，throw()

`return`方法和`throw`方法是可选的，前者是如果`for...of...`提前退出，会调用`return`方法。后者主要是配合`Generator`函数使用。

如果在一个对象完成遍历前，需要释放资源，可以部署`return`方法。`return`方法必须返回一个对象，这是`Generator`的规格决定的。

```js
function readLinesSync(file) {
  return {
    [Symbol.iterator]() {
      return {
        next() {
          return { done: false };
        },
        return() {
          file.close();
          return { done: true };
        }
      };
    }
  };
}

// 情况一
for (let line of readLinesSync(fileName)) {
  console.log(line);
  break;
}

// 情况二
for (let line of readLinesSync(fileName)) {
  console.log(line);
  throw new Error();
}
```

情况一输出文件的第一行以后，就会执行`return`方法，关闭这个文件；情况二会在执行`return`方法关闭文件之后，再抛出错误。

## for...of...与其他遍历方法的比较

### for...in...

`JavaScript`原有的`for...in...`循环，只能获得对象的键名，不能直接获取键值。`ES6`提供`for...of`循环，允许遍历获得键值。数组的`for..of..`只返回具有数字索引的属性，和`for...in...`不同。

```js
var arr = ['a', 'b', 'c', 'd'];

for (let a in arr) {
  console.log(a); // 0 1 2 3
}

for (let a of arr) {
  console.log(a); // a b c d
}

let arr = [3, 5, 7];
arr.foo = 'hello';

for (let i in arr) {
  console.log(i); // "0", "1", "2", "foo"
}

for (let i of arr) {
  console.log(i); //  "3", "5", "7"
}
```

### for...in... 缺点

- 数组的键名是数字，但是`for...in`循环是以字符串作为键名“0”、“1”、“2”等等。
- `for...in`循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
- 某些情况下，`for...in`循环会以任意顺序遍历键名。

### for...of... 优点

- 有着同`for...in`一样的简洁语法，但是没有`for...in`那些缺点。
- 不同于`forEach`方法，它可以与`break`、`continue`和`return`配合使用。
- 提供了遍历所有数据结构的统一操作接口。

## 生成遍历器对象的方法

- `entries()` 返回一个遍历器对象，用来遍历`[键名, 键值]`组成的数组。对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用`entries`方法。
- `keys()` 返回一个遍历器对象，用来遍历所有的键名。
- `values()` 返回一个遍历器对象，用来遍历所有的键值。
