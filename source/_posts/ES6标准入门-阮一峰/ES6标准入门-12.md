---
title: ES6标准入门-12
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-03-02 22:22:50
visible:
---


# Promise 的含义

`Primise`是异步编程的一种解决方案，传统的解决方案多是通过回调函数和事件来实现。`Promise`更合理和更强大，由社区提出，`ES6`将其写进了语言标准，统一了用法，原生提供了`Promise`对象。

所谓`Promise`简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是异步操作）。从语法上来说`Promise`就是一个对象，从它可以获取异步操作的消息，`Promise`提供统一的`API`，各种异步操作都可以用同样的方法处理。

## 特点

`Promise`对象的状态不受外部影响。`Promise`对象代表一个异步操作，有三种状态，两个过程。`pending`（进行中）到`fulfilled`（已成功）的过程为`resolve`（解决）。`pending`到`rejected`（已失败）的过程称为`reject`（失败）。只有异步操作的结果可以决定当前是哪种状态，任何其它的操作都无法改变状态。

状态一旦改变，就不会再变，任何时候都可以得到这个结果。一共就两个状态，只要这两种状况发生，状态就凝固了，这时被称为`resolved`（已定型）。如果改变发生后再对`Promise`添加回调函数，也会立即得到这个结果。与事件循环机制完全不同，事件的特点是如果你错过了再去监听，结果是得不到的。

有了`Promise`对象，就可以将异步的操作以同步的方式表现出来，避免了层层嵌套的回调函数，接口也是统一的。

缺点也很明显，一旦新建`Promise`它就会立即执行，无法中途取消。如果不设置回调函数，`Promise`内部错误无法反应到外部。处于`pending`状态时，无法得知进展到哪一步，是刚刚开始还是即将完成。

## 基本用法

`ES6`规定，`Promise`是一个构造函数，用来生成`Promise`实例。

```js
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});
```

`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数（JS 引擎提供），不需要自己部署。

`resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；

`reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

生成实例后，可以用`then`的方法指定这两个状态的回调函数，这两个回调函数都接收`Promise`不同状态下传出对象的值作为参数。

```js
promise.then(
  function(value) {
    // success
  },
  function(error) {
    // failure
  }
);
```

上述代码执行后就会先显示`pending`状态，过`100ms`后打印出`done`。

```js
let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved
```

因为`Promise`新建后立即执行，所以先打印`Promise`，之后输出同步的任务`Hi`，最后`then`方法指定的回调函数会在同步任务执行之后才会执行，所以`resolve`最后输出。

如果调用`resolve`函数和`reject`函数时带有参数，那么它们的参数会被传递给回调函数。`reject`函数的参数通常是`Error`对象的实例，表示抛出的错误；`resolve`函数的参数除了正常的值以外，还可能是另一个`Promise`实例，比如像下面这样。

```js
const p1 = new Promise(function(resolve, reject) {
  // ...
});

const p2 = new Promise(function(resolve, reject) {
  // ...
  resolve(p1);
});
```

这时`p1`的状态就传递给了`p2`，也就是说，如果`p1`的状态是`pending`，那么`p2`的回调函数就会等待`p1`的状态改变之后再执行；如果`p1`的状态已经改变了，变成了`resolve`或`reject`，那么`p2`的回调函数会立即执行。

`Promise`调用`resolve`或`reject`不会终结它们之后的语句的执行，并且立即`resolved`的`Promise`是在本轮事件循环的末尾执行，所以会后与后面同步代码的执行。但是按照常理来说，这两个方法执行之后`Promise`的使命就结束了，最好加一个`return`，并将后续操作放在`then`里面。

```js
new Promise((resolve, reject) => {
  return resolve(1);
  // 后面的语句不会执行
  console.log(2);
});
```

## Promise 方法

### Promise.prototype.then()

该方法的作用是为`Promise`实例添加状态改变时的回调函数，第一个参数是`resolve`状态的回调函数，第二个（可选）是`reject`状态的回调函数。

`then`方法返回的是一个**新的**`Promise`实例，因此可以采用链式的写法，即`then`之后再写一个`then`。

```js
getJSON('/posts.json')
  .then(function(json) {
    return json.post;
  })
  .then(function(post) {
    // ...
  });
```

### Promise.prototype.catch()

`Promise.prototype.catch`方法是`.then(null, rejection)`或`.then(undefined, rejection)`的别名，用于指定发生错误时的回调函数。

```js
getJSON('/posts.json')
  .then(function(posts) {
    // ...
  })
  .catch(function(error) {
    // 处理 getJSON 和 前一个回调函数运行时发生的错误
    console.log('发生错误！', error);
  });
```

不光`Promise`发生的错误可以被捕获，`then`方法中发生的错误也可以被捕获。如果`Promise`的状态变为了`resolve`再抛出错误就不会被捕获了。

`Promise`的`catch`方法有冒泡性质，会一直向后传递，直到捕获为止。也就是最后一个`catch`总会捕获到之前所有的错误。

一般来说不要在`then`方法里传第二个参数，总是使用`catch`方法。

```js
// bad
promise.then(
  function(data) {
    // success
  },
  function(err) {
    // error
  }
);

// good
promise
  .then(function(data) {
    //cb
    // success
  })
  .catch(function(err) {
    // error
  });
```

第二种更接近于同步的写法，如果没有使用`catch`方法指定错误处理的回调函数，`Promise`对象抛出的错误不会传递到外层代码。这是和`try...catch...`的不同之处，通俗来说，`Promise`会将错误默默吃掉，不影响后面的代码执行。

```js
const someAsyncThing = function() {
  return new Promise(function(resolve, reject) {
    // 下面一行会报错，因为x没有声明
    resolve(x + 2);
  });
};

someAsyncThing().then(function() {
  console.log('everything is great');
});

setTimeout(() => {
  console.log(123);
}, 2000);
// Uncaught (in promise) ReferenceError: x is not defined
// 123
```

`catch`方法返回的也是一个`Promise`，后面接着可以调用`then`方法，所以一般建议`Promise`对象后边总是跟着`catch`方法。如果使用`.catch.then`形式的语法但是`Promise`没有报错，会直接跳过`catch`。`catch`方法返回的也是一个新的`Promise`实例。

可是这样写的意义不大，如果将`catch`放在`then`的后面，可以捕获之前的所有错误。

### Promise.prototype.finally()

`finally`方法用于指定不管`Promise`对象的最后状态如何，都会执行的操作。

```js
promise
.then(result => {···})
.catch(error => {···})
.finally(() => {···});
```

`finally`不接收任何参数，这就意味着`finally`的操作是和状态无关的，例如服务器使用`Promise`处理请求，最后关闭服务器的操作就很适合用`finally`。

```js
server
  .listen(port)
  .then(function() {
    // ...
  })
  .finally(server.stop);
```

`finally`本质上是`then`方法的特例，因为`then`方法是两种状态各指定一个回调，`finally`可以看成是将`then`的两种状态指定为同一个回调函数。

```js
Promise.prototype.finally = function(callback) {
  let P = this.constructor;
  return this.then(
    value => P.resolve(callback()).then(() => value),
    reason =>
      P.resolve(callback()).then(() => {
        throw reason;
      })
  );
};
```

### Promise.all()

`Promise.all()`方法用于将多个`Promise`实例，包装成一个新的`Promise`实例。

```js
const p = Promise.all([p1, p2, p3]);
```

该方法参数必须是一个数组或具有`Iterator`接口的数据类型，返回的每个成员都是`Promise`实例。如果不是，则调用`Promise.resolve()`方法转化为`Promise`实例。

有两种情况：

1. 只有`p1`、`p2`、`p3`的状态都变成`fulfilled`，`p`的状态才会变成`fulfilled`，此时`p1`、`p2`、`p3`的返回值组成一个数组，传递给`p`的回调函数。

2. 只要`p1`、`p2`、`p3`之中有一个被`rejected`，`p`的状态就变成`rejected`，此时第一个被`reject`的实例的返回值，会传递给`p`的回调函数。

如果作为参数的`Promise`实例自己定义了`catch`方法，状态变为`reject`并不会触发`Promise.all`的`catch`方法。因为`Promise.all`不会关心参数内部是怎么实现的，只看状态，自己定义了`catch`方法后返回的是一个状态为`resolve`的新的实例，所以不会触发。如果没有自己的`catch`方法，那么就会触发`Promise.all`的`catch`方法。

### Promise.race()

参数要求和`Promise.all`相同，不同的是行为，`Promise.all`返回所有的，而`Promise.race()`只返回最先返回的，先到先得。

```js
const p = Promise.race([p1, p2, p3]);
```

上面代码中，只要`p1`、`p2`、`p3`之中有一个实例率先改变状态，`p`的状态就跟着改变。那个率先改变的`Promise`实例的返回值，就传递给`p`的回调函数。

```js
const p = Promise.race([
  fetch('/resource-that-may-take-a-while'),
  new Promise(function(resolve, reject) {
    setTimeout(() => reject(new Error('request timeout')), 5000);
  })
]);
// 如果5s钟之内没有结果，就会将p的状态变为reject。
p.then(console.log).catch(console.error);
```

### Promise.allSettled()

`Promise.allSettled()`方法接受一组`Promise`实例作为参数，包装成一个新的 `Promise`实例。只有等到所有这些参数实例都返回结果，不管是`fulfilled`还是`rejected`，包装实例才会结束。

```js
const promises = [fetch('/api-1'), fetch('/api-2'), fetch('/api-3')];

await Promise.allSettled(promises);
removeLoadingIndicator();
```

该方法不关心`Promise`的结果是成功还是失败，只关心这些操作结束了没有。该方法只有确保所有操作都结束才返回一个数组，每个数组成员都是一个对象。

![](111.jpg)

### Promise.any()

`Promise.any()`跟`Promise.race()`方法很像，只有一点不同，就是不会因为某个 `Promise`变成`rejected`状态而结束。只要参数实例有一个变成`fulfilled`状态，包装实例就会变成`fulfilled`状态；如果所有参数实例都变成`rejected`状态，包装实例就会变成`rejected`状态。

这个方法目前是一个提案，并且抛出的错误不是一般的错误，而是一个数组，数组中存着每一个成员对应的被`reject`操作抛出的错误。

### Promise.resolve()

该方法用来将现有对象转为`Promise`对象。

```js
Promise.resolve('foo');
// 等价于
new Promise(resolve => resolve('foo'));
```

#### 参数是一个 Promise 实例

该方法不做任何修改，直接返回这个实例。

#### 参数是一个 thenable 对象

就是具有`.then`方法的对象：

```js
let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};
```

`Promise.resolve`方法会将这个对象转为`Promise`对象，然后就立即执行`thenable`对象的`then`方法。

```js
let thenable = {
  then: function(resolve, reject) {
    resolve(42);
  }
};

let p1 = Promise.resolve(thenable);
p1.then(function(value) {
  console.log(value); // 42
});
```

#### 参数不是具有 then 方法的对象，或根本不是对象

如果参数是一个原始值，或者是一个不具有`then`方法的对象，则`Promise.resolve`方法返回一个新的`Promise`对象，状态为`resolved`。

```js
const p = Promise.resolve('Hello');

p.then(function(s) {
  console.log(s);
});
// Hello
```

上面代码生成一个新的`Promise`对象的实例`p`。由于字符串`Hello`不属于异步操作（判断方法是字符串对象不具有`then`方法），返回`Promise`实例的状态从一生成就是`resolved`，所以回调函数会立即执行。`Promise.resolve`方法的参数，会同时传给回调函数。

#### 不带有任何参数

`Promise.resolve()`方法允许调用时不带参数，直接返回一个`resolved`状态的 `Promise`对象。

如果希望得到一个`Promise`对象，对方便的就是直接调用`Promise.resolve()`。

立即`resolve()`的`Promise`对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。

```js
setTimeout(function() {
  console.log('three');
}, 0);

Promise.resolve().then(function() {
  console.log('two');
});

console.log('one');

// one
// two
// three
```

### Promise.reject()

`Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected`。

```js
const p = Promise.reject('出错了');
// 等同于
const p = new Promise((resolve, reject) => reject('出错了'));

p.then(null, function(s) {
  console.log(s);
});
// 出错了
```

`Promise.reject()`方法的参数，会原封不动地作为`reject`的理由，变成后续方法的参数。这一点与`Promise.resolve`方法不一致。

```js
const thenable = {
  then(resolve, reject) {
    reject('出错了');
  }
};

Promise.reject(thenable).catch(e => {
  console.log(e === thenable);
});
// true
```

### Promise.try()

有些时候不想区分一个函数是同步还是异步操作，只想用`Promise`来处理它，这样就可直接调用`Promise`的方法。可以像下面那样写：

```js
Promise.resolve().then(f);
```

如果`f`是同步函数，就会被放到当前时间循环的末尾执行。所以需要一种方法，让异步函数异步执行，同步函数同步执行，`JS`有两种解决方案。

#### 使用 async

```js
const f = () => console.log('now');
(async () => f())();
console.log('next');
// now
// next
```

如果是异步的，可以使用`then`指定下一步，但是`f()`抛出的错误需要使用`promise.catch`方法捕获。

#### 使用 new Promise()

```js
const f = () => console.log('now');
(() => new Promise(resolve => resolve(f())))();
console.log('next');
// now
// next
```

两种方法的大体思路就是使用立即执行的匿名函数，同步操作可以立即执行。

有一个新提案，就是使用`Promise.try()`来作为一个通用的方法：

```js
const f = () => console.log('now');
Promise.try(f);
console.log('next');
// now
// next
```

由于`catch`只能捕获异步错误，同步错误无法捕获。有时需要使用`try...catch...`来捕获，可以直接使用`Promise.try()`精简代码。

```js
Promise.try(() => database.users.get({id: userId}))
  .then(...)
  .catch(...)
```
