---
title: ES6标准入门-10
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-02-29 18:08:18
visible:
---

# Set 和 Map 数据结构

## Set

### 基本概念

`ES6`新增了新的数据结构`Set`，类似于数组，但是成员的值都是唯一的，没有重复的值。而它判断值是否重复的依据和`===`差不多，唯一的区别在于`Set`认为`NaN`和`NaN`全等。

`Set`生成方式有两种，第一种是通过构造函数生成，之后使用`Set`的`add()`方法添加元素；第二种是在构造函数中接收一个数组或具有`iterable`接口的其他数据结构，用来初始化。

```js
const s = new Set();

[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));

// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set];
// [1, 2, 3, 4]
```

向`Set`加入值时，不会发生类型转换，`'5'`和`5`不是一个值，如果加入两个空对象，会都加入进去，因为对象总是不相等的。

### 实例方法和属性

#### 属性

- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。
- `Set.prototype.size`：返回`Set`实例的成员总数。

#### 方法

- `Set.prototype.add(value)`：添加某个值，返回`Set`结构本身。
- `Set.prototype.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `Set.prototype.has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。
- `Set.prototype.clear()`：清除所有成员，没有返回值。

```js
s.add(1)
  .add(2)
  .add(2);
// 注意2被加入了两次

s.size; // 2

s.has(1); // true
s.has(2); // true
s.has(3); // false

s.delete(2);
s.has(2); // false
```

`Array.from()`可以将`Set`转为数组，顺便去重。

```js
function dedupe(array) {
  return Array.from(new Set(array));
}

dedupe([1, 1, 2, 3]); // [1, 2, 3]
```

#### 遍历操作

`Set`实例有四个遍历方法，可以用于遍历成员。

- `Set.prototype.keys()`：返回键名的遍历器
- `Set.prototype.values()`：返回键值的遍历器
- `Set.prototype.entries()`：返回键值对的遍历器
- `Set.prototype.forEach()`：使用回调函数遍历每个成员

`Set`的遍历顺序就是插入顺序，注意与其他对象遍历时的区别。而且由于`Set`没有键名，只有键值，所以前两个方法的行为完全一致。`Set`也能不能通过`a[key]`的方式访问元素。

![](111.jpg)

```js
let set = new Set(['red', 'green', 'blue']);

for (let item of set.keys()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item);
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]
```

因为`Set`部署了遍历器接口，可以使用`for...of...`直接遍历。遍历器接口就是它的`values`方法：

```js
Set.prototype[Symbol.iterator] === Set.prototype.values;
// true
```

`forEach`方法和数组一样，没有区别，可以有第二个表示`this`的参数。第一个回调函数中的前两个参数任何时候都是相同的。

而`...`符号内部使用的就是`for...of...`方法，可以配合`filter`方法，`map`方法使用。

```js
let set = new Set([1, 2, 3]);
set = new Set([...set].map(x => x * 2));
// 返回Set结构：{2, 4, 6}

let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x => x % 2 == 0));
// 返回Set结构：{2, 4}
```

但是`Set`中没有可以修改原`Set`的方法，都是返回一个新的`Set`，如果想实现修改源对象，需要曲线救国。

```js
// 方法一
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val => val * 2));
// set的值是2, 4, 6

// 方法二
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val => val * 2));
// set的值是2, 4, 6
```

## WeakSet

`WeackSet`结构与`Set`类似，也是不重复值的集合，因为不能遍历，所以`Set`遍历相关的方法没有，只有`has`，`delete`，`add`三个方法。不同的地方有两点。

### 成员不同

`WeakSet`中的成员只能是对象，不能是其他类型的值。

```js
const ws = new WeakSet();
ws.add(1);
// TypeError: Invalid value used in weak set
ws.add(Symbol());
// TypeError: invalid value used in weak set
```

### 垃圾回收机制

垃圾回收机制引擎不会考虑`WeakSet`中的对象，就算在`WeakSet`中引用了对象，也会回收。因为`WeakSet`中的对象是弱引用。因此`WeakSet`·`适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在`WeakSet`里面的引用就会自动消失。

`WeakSet`的成员是不适合引用的，因为它会随时消失。另外，由于`WeakSet`内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此`ES6`规定`WeakSet`不可遍历。

## Map

### 基本概念

`JS`中的对象，本质是键值对的集合（HASH 结构），但是键值只能是字符串。这给使用增加了很大不便。

`ES6`中新增了一个`Map`数据结构，类似于对象，也是键值对的集合，但是键的范围包括各种类型，提供了`值——值`对应的`HASH`结构实现。在键值对方面使用`Map`比对象更好用。

`Map`数据结构可以通过两种方式新建一个`Map`。第一种是构造函数`new Map()`新建，再通过`set`方法传入键值对。第二种方法是通过向构造函数中传入一个二维数组，该数组的成员就是一个个表示键值对的数组。

```js
const m = new Map();
const o = { p: 'Hello World' };

m.set(o, 'content');
m.get(o); // "content"

m.has(o); // true
m.delete(o); // true
m.has(o); // false

const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

map.size; // 2
map.has('name'); // true
map.get('name'); // "张三"
map.has('title'); // true
map.get('title'); // "Author"
```

任何具有`Iterator`接口的数据结构，每个成员都是一个双元素的数组结构，就可以当做构造函数的参数传入，生成一个新的`Map`。

```js
const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo'); // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz'); // 3
```

重复的值也是后边覆盖前边的，如果读取一个未知的键和对象没什么两样。

`Map`中键值如果是对象类型，必须使用一个对象的引用来访问，否则会认为是两个键值。这解决了同名碰撞的问题，`Map`中使用`Object.is()`相同的判定方式来进行判断键值是否是一个。

```js
const map = new Map();

map.set(['a'], 555);
map.get(['a']); // undefined

const map = new Map();

const k1 = ['a'];
const k2 = ['a'];

map.set(k1, 111).set(k2, 222);

map.get(k1); // 111
map.get(k2); // 222
```

### 实例方法和属性

#### 属性

- `size`：返回`Map`结构成员总数。

```js
const map = new Map();
map.set('foo', true);
map.set('bar', false);

map.size; // 2
```

#### 方法

- `Map.prototype.set(key, value)`：添加某个键值对，`key`存在，键值会更新，否则新建。返回`Map`结构本身。
- `Map.prototype.delete(key)`：删除某个键，返回一个布尔值，表示删除是否成功。
- `Map.prototype.has(value)`：返回一个布尔值，表示该键是否为`Map`的成员。
- `Map.prototype.clear()`：清除所有成员，没有返回值。
- `Map.prototype.get(key)`：`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

### 遍历操作

`Map`结构原生提供三个遍历器生成函数和一个遍历方法。遍历顺序就是插入顺序。

- `Map.prototype.keys()`：返回键名的遍历器。
- `Map.prototype.values()`：返回键值的遍历器。
- `Map.prototype.entries()`：返回所有成员的遍历器。
- `Map.prototype.forEach()`：遍历`Map`的所有成员。

![](222.jpg)

注意返回的是遍历器，不是数组，还需要使用`for...of...`来遍历。

`Map`结构可以使用扩展运算符转为数组结构，顺带可以结合数组的`map`，`filter`方法。

```js
const map0 = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');

const map1 = new Map([...map0].filter(([k, v]) => k < 3));
// 产生 Map 结构 {1 => 'a', 2 => 'b'}

const map2 = new Map([...map0].map(([k, v]) => [k * 2, '_' + v]));
// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}
```

### 与其他数据结构的相互转换

#### Map 和数组相互转换

```js
// 使用扩展运算符
const myMap = new Map().set(true, 7).set({ foo: 3 }, ['abc']);
[...myMap];
// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]

// 使用构造函数
new Map([
  [true, 7],
  [{ foo: 3 }, ['abc']]
]);
// Map {
//   true => 7,
//   Object {foo: 3} => ['abc']
// }
```

#### Map 和对象相互转换

如果`Map`的键都是字符串，可以无损转换，如果非字符串的键名，会先转为字符串，再转为对象。

```js
function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k, v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const myMap = new Map().set('yes', true).set('no', false);
strMapToObj(myMap);
// { yes: true, no: false }

// 对象转 Map ，现将对象转为键值对数组，之后转为 Map
let obj = { a: 1, b: 2 };
let map = new Map(Object.entries(obj));
```

#### Map 和 JSON 互转

`Map`的键名都是字符串，直接转对象`JSON`。

```js
function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set('yes', true).set('no', false);
strMapToJson(myMap);
// '{"yes":true,"no":false}'
```

`Map`的键名含有非字符串，转为数组`JSON`。

```js
function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({ foo: 3 }, ['abc']);
mapToArrayJson(myMap);
// '[[true,7],[{"foo":3},["abc"]]]'
```

`JSON`所有键名都是字符串，直接转。

```js
function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap('{"yes": true, "no": false}');
// Map {'yes' => true, 'no' => false}
```

`JSON`就是一个数组，每个数组元素都是一个有两个成员的数组，这样就可以一一对应转为`Map`。

```js
function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap('[[true,7],[{"foo":3},["abc"]]]');
// Map {true => 7, Object {foo: 3} => ['abc']}
```

## WeakMap

和`Map`类似，也用于生成键值对的集合。

```js
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = { foo: 1 };
wm1.set(key, 2);
wm1.get(key); // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([
  [k1, 'foo'],
  [k2, 'bar']
]);
wm2.get(k2); // "bar"
```

### 与 Map 区别

#### 只接受对象作为键名（null）除外

```js
const map = new WeakMap();
map.set(1, 2);
// TypeError: 1 is not an object!
map.set(Symbol(), 2);
// TypeError: Invalid value used as weak map key
map.set(null, 2);
// TypeError: Invalid value used as weak map key
```

#### WeakMap 内部键名指向的对象，不计入垃圾回收机制

`WeakMap`的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。

```js
const e1 = document.getElementById('foo');
const e2 = document.getElementById('bar');
const arr = [
  [e1, 'foo 元素'],
  [e2, 'bar 元素']
];
```

如果在`arr`中修改了`e1`或`e2`，就形成了对`e1`，`e2`的引用，使用之后必须手动将它们指向`null`。

`WeakMap`就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，`WeakMap`里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用`WeakMap`。`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。

和`WeakSet`不同的是，`WeakMap`弱引用的只是键名，而不是键值。键值依然是正常引用。

```js
const wm = new WeakMap();
let key = {};
let obj = { foo: 1 };

wm.set(key, obj);
obj = null;
wm.get(key);
// Object {foo: 1}
```

### WeakMap 的语法

`WeakMap`与`Map`在`API`上的区别主要是两个，一是没有遍历操作（即没有`keys()`、`values()`和`entries()`方法），也没有`size`属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持`clear`方法。因此，`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`。

```js
const wm = new WeakMap();

// size、forEach、clear 方法都不存在
wm.size; // undefined
wm.forEach; // undefined
wm.clear; // undefined
```

### WeakMap 的用途

- `DOM`节点作为键名，节点的状态作为键值，每当`DOM`节点被删除，状态自动消失，没有内存泄露的风险。
- 部署私有属性，使用`WeakMap`来部署类的内部属性，如果实例被销毁，内部属性也随之消失，不存在内存泄漏

```js
const _counter = new WeakMap();
const _action = new WeakMap();

class Countdown {
  constructor(counter, action) {
    _counter.set(this, counter);
    _action.set(this, action);
  }
  dec() {
    let counter = _counter.get(this);
    if (counter < 1) return;
    counter--;
    _counter.set(this, counter);
    if (counter === 0) {
      _action.get(this)();
    }
  }
}

const c = new Countdown(2, () => console.log('DONE'));

c.dec();
c.dec();
// DONE
```
