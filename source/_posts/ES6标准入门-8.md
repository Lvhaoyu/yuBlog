---
title: ES6标准入门-8
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-02-28 18:11:21
visible:
---


# 对象的扩展和新增方法

## 属性的简洁表示法

`ES6`允许在大括号里，直接写入变量和函数，作为对象的属性和方法，这样的书写更简洁。

```js
const foo = 'bar';
const baz = { foo };
baz; // {foo: "bar"}

// 等同于
const baz = { foo: foo };
```

`foo`写在大括号中，属性名就是变量名，属性值就是变量值。

方法也可以简写：

```js
const o = {
  method() {
    return 'Hello!';
  }
};

// 等同于

const o = {
  method: function() {
    return 'Hello!';
  }
};
```

简洁的写法不能用作构造函数：

```js
const obj = {
  f() {
    this.foo = 'bar';
  }
};

new obj.f(); // 报错
```

## 属性名表达式

在`ES5`中，有两种方法来定义对象的属性：

```js
// 方法一
obj.foo = true;

// 方法二
obj['a' + 'bc'] = 123;  === obj['abc']
```

第一种方法是直接用标识符作为属性名，第二种是用表达式作为属性名，需要将表达式放在方括号之内。

如果使用字面量方式定义对象，在`ES5`中只能使用方法一来添加属性。`ES6`允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。

```js
let propKey = 'foo';

let obj = {
  [propKey]: true,
  ['a' + 'bc']: 123
};

let obj = {
  ['h' + 'ello']() {
    return 'hi';
  }
};

obj.hello(); // hi
```

但是属性名表达式与表示法不能在一起用，会报错，而且属性名表达式如果是一个对象，默认情况下会将对象转为字符串`[object,object]`。

```js
const keyA = { a: 1 };
const keyB = { b: 2 };

const myObject = {
  [keyA]: 'valueA',
  [keyB]: 'valueB'
};

myObject; // Object {[object Object]: "valueB"}
```

## 方法的 name 属性

函数的`name`属性返回函数名，对象中的方法也是函数，`name`属性也返回其函数名。

如果对象的方法中使用了`getter`（取值函数 get）或`setter`（存值函数 set），`name`属性则挂载到该方法的`get`和`set`属性上面。

```js
const obj = {
  get foo() {},
  set foo(x) {}
};

obj.foo.name;
// TypeError: Cannot read property 'name' of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

descriptor.get.name; // "get foo"
descriptor.set.name; // "set foo"
```

`bind`方法创造的函数，`name`属性返回`bound`加原函数名。`Function`构造函数创造的函数，`name`返回`anonymous`（匿名）。

```js
new Function().name; // "anonymous"

var doSomething = function() {
  // ...
};
doSomething.bind().name; // "bound doSomething"
```

如果对象的方法是一个`Symbol`值，那么`name`属性返回`Symbol`值的描述。

```js
const key1 = Symbol('description');
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {}
};
obj[key1].name; // "[description]"
obj[key2].name; // ""
```

## 属性的可枚举性和遍历

### 可枚举性

对象的每个属性都有一个描述对象，用来控制属性的行为，使用`Object.getOwnPropertyDescriptor()`方法可以获取该属性的描述对象。

```js
let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, 'foo');
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
```

描述对象的`enumerable`属性，称为**可枚举属性**，如果该属性为`false`，表示某些操作会忽略当前属性。

目前有四个操作会忽略`emumerable`为`false`的属性。

- `for...in...`循环：只遍历对象自身和继承的可枚举属性（`ES6`）
- `Object.keys()`：返回对象自身的所有可枚举的属性的键名（`ES6`）
- `JSON.stringify()`：只串行化对象自身的可枚举属性
- `Object.assign()`：忽略不可枚举属性，只拷贝对象自身的可枚举的属性

引入`enumerable`属性主要是为了规避`for...in...`会遍历到所有属性。

`ES6`规定，所有`Class`的原型方法都是不可枚举的。

```js
Object.getOwnPropertyDescriptor(
  class {
    foo() {}
  }.prototype,
  'foo'
).enumerable;
// false
```

### 属性的遍历

`ES6`有五种方法可以遍历对象属性，之前提到了两种，都是不能遍历`Symbol`属性的。

还有三种：

- Object.getOwnPropertyNames：返回一个数组，包含对象自身的所有属性（不含 `Symbol`属性，但是包括不可枚举属性）的键名。
- Object.getOwnPropertySymbols：返回一个数组，包含对象自身的所有`Symbol`属性的键名。
- Reflect.ownKeys：返回一个数组，包含对象自身的所有键名，不管键名是`Symbol`或字符串，也不管是否可枚举。

这五种方法的遍历顺序为：

- 首先遍历所有数值键，按照数值升序排列。
- 其次遍历所有字符串键，按照加入时间升序排列。
- 最后遍历所有`Symbol`键，按照加入时间升序排列。

```js
Reflect.ownKeys({ [Symbol()]: 0, b: 0, 10: 0, 2: 0, a: 0 });
// ['2', '10', 'b', 'a', Symbol()]
```

## super 关键字

`this`总是指向函数所在的当前对象，`ES6`新增了`super`关键字，指向当前对象的原型对象。

```js
const proto = {
  foo: 'hello'
};

const obj = {
  foo: 'world',
  find() {
    return super.foo;
  }
};

Object.setPrototypeOf(obj, proto); // 给obj指定一个新的原型proto
obj.find(); // "hello"
```

`super`只能用于对象的方法中，也只能像上个代码块那样调用。

## 对象的扩展运算符

### 对象的解构赋值

对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历（`enumerable`），但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。

### 扩展运算符

对象的扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。

和数组中的扩展运算符类似。对象的扩展运算符等同于使用`Object.assign()`方法，只是实现了浅拷贝，即只拷贝了对象实例的属性。

如果想完整克隆一个对象，可以采用以下写法：

```js
// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(Object.create(Object.getPrototypeOf(obj)), obj);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
```

对象的扩展运算符可以用于合并两个对象:

```js
let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
```

如果用户自定义属性放在扩展运算符后面，扩展运算符内部的同名属性会被覆盖掉（总是后面的覆盖前面的）。

![](111.jpg)

这样可以简单的修改对象的部分属性，只要将要修改的属性写在后面就可以覆盖了：

```js
let newVersion = {
  ...previousVersion,
  name: 'New Name' // Override the name property
};
```

扩展运算符的参数对象之中，如果有取值函数`get`，这个函数会执行，至于为什么会被执行，我猜测应该是扩展运算符相当于取值操作，所以需要执行。

```js
// 并不会抛出错误，因为 x 属性只是被定义，但没执行
let aWithXGetter = {
  ...a,
  get x() {
    throw new Error('not throw yet');
  }
};

// 会抛出错误，因为 x 属性被执行了
let runtimeError = {
  ...a,
  ...{
    get x() {
      throw new Error('throw now');
    }
  }
};
```

## 链判断运算符

在业务代码中，如果要读取对象内部的某个属性，需要判断对象是否存在。

```js
const firstName =
  (message &&
    message.body &&
    message.body.user &&
    message.body.user.firstName) ||
  'default';
```

或者使用三元运算符：

```js
const fooInput = myForm.querySelector('input[name=foo]');
const fooValue = fooInput ? fooInput.value : undefined;
```

在`ES2020`中引入了“链判断运算符”（`?.`），简化了写法：

```js
const firstName = message?.body?.user?.firstName || 'default';
```

运算时会在链式调用时判断，左侧的对象是否为`null`或`undefined`，如果是，就不继续运算，直接返回`undefined`。

![](222.jpg)

有三种用法：

- obj?.prop
- obj?.[expr]
- func?.(...arg)

```js
iterator.return?.(); // 判断对象方法是否存在，如果存在，立即执行
```

注意使用方法调用时，如果括号之前的不是函数，不可以调用，也会报错。

该方法的几个注意点：

短路机制：

```js
a?.[++x];
// 等同于
a == null ? undefined : a[++x];
```

判断成功直接终止，不进行表达式求值。

delete 运算符：

```js
delete a?.b;
// 等同于
a == null ? undefined : delete a.b;
```

如果对象属性不存在，不会进行`delete`运算。

括号的影响：

只对括号内部有影响，外部没影响，在使用链式运算符的情况下不应该使用括号。

```js
(a?.b).c(
  // 等价于
  a == null ? undefined : a.b
).c;
```

报错场合：

```js
// 构造函数
new a?.()
new a?.b()

// 链判断运算符的右侧有模板字符串
a?.`{b}`
a?.b`{c}`

// 链判断运算符的左侧是 super
super?.()
super?.foo

// 链运算符用于赋值运算符左侧
a?.b = c
```

右侧不能为十进制数值：

为了保证兼容以前的代码，允许`foo?.3:0`被解析成`foo ? .3 : 0`，因此规定如果?.后面紧跟一个十进制数字，那么`?.`不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。

## Null 判断运算符

`ES2020`引入了新的`Null`判断运算符`??`，行为类似`||`，但是只有运算符左侧的值为`null`或`undefined`的时候，才会返回右侧的值。

```js
const headerText = response.settings.headerText ?? 'Hello, world!';
const animationDuration = response.settings.animationDuration ?? 300;
const showSplashScreen = response.settings.showSplashScreen ?? true;
```

可以和链式运算符配合使用返回默认值：

```js
const animationDuration = response.settings?.animationDuration ?? 300;
```

如果该运算符与`&&`和`||`一起使用，必须使用括号表明优先级，否则会报错：

```js
// 报错
lhs && middle ?? rhs
lhs ?? middle && rhs
lhs || middle ?? rhs
lhs ?? middle || rhs

(lhs && middle) ?? rhs;
lhs && (middle ?? rhs);

(lhs ?? middle) && rhs;
lhs ?? (middle && rhs);

(lhs || middle) ?? rhs;
lhs || (middle ?? rhs);

(lhs ?? middle) || rhs;
lhs ?? (middle || rhs);
```

## 对象的新增方法

### Object.is()

`ES5`比较两个值是否相等值能用`===`和`==`。前者不能判断`NaN`、`+0`和`-0`判断为相等，后者会进行类型转换。

在`ES6`新增了`Object.is()`，该方法遵循“Same-value equality”（同值相等）算法，行为大部分与`===`完全一致。

不同之处如下：

```js
+0 === -0; //true
NaN === NaN; // false

Object.is(+0, -0); // false
Object.is(NaN, NaN); // true
```

### Object.assign()

#### 基本使用

该方法用于对象的合并，将源对象（source）的所有可枚举属性复制到目标对象（target），不拷贝继承属性，也不拷贝不可枚举属性，属性名为`Symbol`值得属性，也会被`Object.assign`拷贝。

```js
const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target; // {a:1, b:2, c:3}
```

如果存在同名属性，后面的会覆盖前面的。如果只有一个参数，直接返回该参数。如果参数不是对象，会先转成对象，然后返回。`undefined`和`null`无法转成对象，如果将它们设置为参数，会报错。

![](333.jpg)

如果非对象位于第二个参数（除了字符串），会先转换，如果转换失败就会略过，字符串会转为字符类数组的形式拷贝到目标对象（因为字符串的基本包装类型有可枚举属性）。`undefined`和`null`就不会报错，而是转换失败后略过。

```js
const v1 = 'abc';
const v2 = true;
const v3 = 10;

const obj = Object.assign({}, v1, v2, v3);
// 因为字符串的基本包装类型会产生可枚举属性
console.log(obj); // { "0": "a", "1": "b", "2": "c" }
```

#### 注意的点

##### 浅拷贝

该方法实行的是浅拷贝，不是深拷贝，如果源对象某个属性的值是对象，那么目标对象拷贝到的是对象的引用。

```js
const obj1 = { a: { b: 1 } };
const obj2 = Object.assign({}, obj1);

obj1.a.b = 2;
obj2.a.b; // 2
```

##### 同名属性的替换

对于嵌套的对象，一旦遇到同名属性，`Object.assign`会实行替换，而不是添加。

```js
const target = { a: { b: 'c', d: 'e' } };
const source = { a: { b: 'hello' } };
Object.assign(target, source);
// { a: { b: 'hello' } }
```

##### 数组的处理

`Object.assign`可以用来处理数组，但是会把数组视为对象，键名是索引，键值是元素，同名属性会发生替换。

```js
Object.assign([1, 2, 3], [4, 5]);
// [4, 5, 3]
```

##### 取值函数的处理

`Object.assign`只能进行值的复制，如果复制的是一个取值（getter）函数，那么将求值后再复制。

```js
const source = {
  get foo() {
    return 1;
  }
};
const target = {};

Object.assign(target, source);
// { foo: 1 }
```

#### 常见用途

##### 为对象添加属性

```js
class Point {
  constructor(x, y) {
    Object.assign(this, { x, y });
  }
}
```

##### 为对象添加方法

```js
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
```

##### 克隆对象

```js
function clone(origin) {
  return Object.assign({}, origin);
}
// 拷贝继承的属性
function clone(origin) {
  let originProto = Object.getPrototypeOf(origin);
  return Object.assign(Object.create(originProto), origin);
}
```

##### 合并多个对象

将多个对象合并到某个对象：

```js
const merge = (target, ...sources) => Object.assign(target, ...sources);
```

如果希望合并后返回一个新对象，可以对一个空对象合并：

```js
const merge = (...sources) => Object.assign({}, ...sources);
```

##### 为属性指定默认值

```js
const DEFAULTS = {
  logLevel: 0,
  outputFormat: 'html'
};

function processContent(options) {
  options = Object.assign({}, DEFAULTS, options);
  console.log(options);
  // ...
}
```

原理就是提前写好一个对象，之后作为要拷贝对象的前一个参数，这样就会覆盖同名属性。不过由于浅拷贝的问题，传入对象所有属性的值最好都是简单类型，不要指向另一个对象，否则默认属性可能不起作用。

```js
const DEFAULTS = {
  url: {
    host: 'example.com',
    port: 7070
  }
};

processContent({ url: { port: 8000 } });
// {
//   url: {port: 8000}
// }
```

##### Object.getOwnPropertyDescriptors()

`ES5`对应的`Object.getOwnPropertyDescriptor()`方法会返回某个对象属性的描述对象（descriptor），`ES2017`引入`Object.getOwnPropertyDescriptors()`返回指定对象所有自身属性的（不包含继承）的描述对象。

```js
const obj = {
  foo: 123,
  get bar() {
    return 'abc';
  }
};

Object.getOwnPropertyDescriptors(obj);
// { foo:
//    { value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true },
//   bar:
//    { get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true } }
```

内部实现可以使用`Object.getOwnPropertyDescriptor()`，遍历所有元素，对于每个元素都是用该方法并存入对象中。

该方法可以配合`Object.assign`将赋值函数（setter）拷贝给目标对象。因为`Object.assign`只拷贝属性值，不拷贝背后赋值方法或取值方法。

```js
const source = {
  set foo(value) {
    console.log(value);
  }
};

const shallowMerge = (target, source) =>
  Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
```

也可以配合`Object.create`将对象属性克隆到一个新对象（浅拷贝）：

```js
const clone = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);

// 或者

const shallowClone = obj =>
  Object.create(
    Object.getPrototypeOf(obj),
    Object.getOwnPropertyDescriptors(obj)
  );
```

配合`Object.create`也可以实现一个对象继承另一个对象。因为`Object.create`可以建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`。

```js
const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors({
    foo: 123
  })
);
```

### \_\_proto\_\_属性

`__proto__`属性用来读取或设置当前对象的`prototype`对象，这个标准是浏览器先出，之后`ES6`才加入到正式标准的附录里。该属性指向对象的原型。

```js
// es5 的写法
const obj = {
  method: function() { ... }
};
obj.__proto__ = someOtherObj;

// es6 的写法
var obj = Object.create(someOtherObj);
obj.method = function() { ... };
```

在`ES6`中，明确指出最好用`Object.create()`，`Object.setPrototypeOf()`，`Object.getPrototypeOf()`等操作代替。

### Object.setPrototypeOf()

该方法是`ES6`推出来替代`__proto__`，用来设置一个对象的`prototype`对象，返回参数本身。

```js
// 格式
Object.setPrototypeOf(object, prototype);

// 用法
const o = Object.setPrototypeOf({}, null);

// 等同于

function setPrototypeOf(obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
```

和`Object.assign`参数行为类似，如果第一个参数不是对象，会进行转换，返回第一个参数，看起来该操作没有任何效果。如果第一个参数是`undefined`或`null`，就会报错。

### Object.getPrototypeOf()

该方法与`Object.setPrototypeOf`配套，用来读取一个对象的原型：

```js
Object.getPrototypeOf(obj);
```

参数不是对象会转为对象，`undefined`和`null`无法转成对象会报错。

### Object.keys()，Object.values()，Object.entries()

`ES5`引入了`Object.keys`方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。`ES7`引入了配套的`Object.values`和`Object.entries`作为遍历对象的补充手段，可以使用`for...of...`遍历。

```js
let { keys, values, entries } = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
```

#### Object.values()

该方法返回一个数组，成员是参数对象自身（不含继承）的可枚举属性的键值。会过滤掉属性名为`Symbol`值的属性。如果该方法的参数是一个字符串，返回各个字符组成的一个数组。如果参数不是对象，`Object.values`会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，`Object.values`会返回空数组。

```js
Object.values('foo');
// ['f', 'o', 'o']
```

#### Object.entries()

`Object.entries()`方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。

除了返回值不同，和`Object.values`行为基本一致。

```js
const obj = { foo: 'bar', baz: 42 };
Object.entries(obj);
// [ ["foo", "bar"], ["baz", 42] ]
```

可以使用该方法将对象转为真正的`Map`结构：

```js
const obj = { foo: 'bar', baz: 42 };
const map = new Map(Object.entries(obj));
map; // Map { foo: "bar", baz: 42 }
```

### Object.fromEntries()

`Object.fromEntries()`方法是`Object.entries()`的逆操作，用于将一个键值对数组转为对象。

```js
Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
]);
// { foo: "bar", baz: 42 }
```

该方法的主要目的是将键值对的数据结构转换为对象，特别适合将`Map`数据结构转为对象：

```js
// 例一
const entries = new Map([
  ['foo', 'bar'],
  ['baz', 42]
]);

Object.fromEntries(entries);
// { foo: "bar", baz: 42 }

// 例二
const map = new Map().set('foo', true).set('bar', false);
Object.fromEntries(map);
// { foo: true, bar: false }
```

还可以配合`URLSearchParams`对象，将查询字符串转为对象。

```js
Object.fromEntries(new URLSearchParams('foo=bar&baz=qux'));
```
