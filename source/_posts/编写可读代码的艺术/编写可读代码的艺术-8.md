---
title: 变量对可读性的影响
tags:
  - 职业修养
categories:
  - 读书笔记
  - 编写可读代码的艺术
date: 2020-01-18 08:59:26
visible:
---

# 第九章：变量与可读性

变量的良好使用对程序的理解至关重要，关于变量主要会有以下三个问题：

1. 变量越多，就越难全部跟踪它们的动向。

2. 变量的作用域越大，就需要跟踪它的动向越久。

3. 变量改变得越频繁，就越难以跟踪它的当前值。

本章主要是讲解如何处理这三个问题。

## 减少变量

引入“解释”或“总结”变量会对程序的可读性有很大的提高，因为它们会将较长的表达式拆分。而在某些情况下，变量的定义完全是多余的，下面列举多余变量的例子。

### 没有价值的临时变量

```python
now = datetime.datetime.now()
root_message.last_view_time = now
```

这个`now`很明显就是一个没有价值的变量，有以下几个原因：

- 它没有拆分任何复杂的表达式。

- 它没有做更多的澄清——表达式`datetime.datetime.now()`已经很清楚了。

- 它只用过一次，因此它并没有压缩任何冗余代码。

将代码改为：

```python
root_message.last_view_time = datetime.datetime.now()
```

一般来说，`now`这种变量的出现可能是因为在定义的时候被认为是需要使用多次的，实际并没有。这就需要给它优化掉。

### 减少中间结果

![](00062.jpg)

这段代码很明显，`index_to_remove`多余了。而且这个临时变量的引入会让代码理解起来更麻烦。本来就是简单的从数组中删除一个值而已，还加上了终止循环语句，直接`return`会更加简单。

![](00078.jpg)

核心思想是**大部分的中间变量可以通过提前返回来去除**。

### 减少控制流变量

```javascript
let done = false;

while(xxx && !done) {
    ...
    if(...){
        done = true;
        continue; // 跳出当前循环直接进入下一个循环
    }
}
```

这个`done`就是一个控制流变量，作用就是控制代码的执行。和程序中的数据流毫无关系。控制流变量完全可以通过**更好的运用结构化编程而消除**。

```javascript
while(xxx){
    ...
    if(...) {
        break; // 直接跳出循环且最后一个循环值不执行
    }
}
```

如果嵌套过多，可以将多余的操作封装到一个新的函数中。易于理解的代码，不会多于三个变量。

## 缩小变量的作用域

“避免全局变量”这个建议不止在`JavaScript`中重点强调，在其他编程语言中也有类似的问题。如果定义了全局变量，很难去追踪这些全局变量以及在哪里使用了它们。而且如果涉及到了“命名空间污染”（局部变量和全局变量的名字重复），定义的局部变量也可能会改变全局变量的值。

让所有的变量都缩小它们的作用域是增加代码可读性至关重要的一个思想，即**让你的变量对尽量少的代码可见**。

很多编程语言提供了多重作用域/访问级别，包括模块、类、函数以及语句块作用域。通常越严格的访问控制越好，因为这意味着该变量对更少的代码行“可见”。

为什么要这么做？因为这样有效地减少了读者同时需要考虑的变量个数。如果你能把所有的变量作用域都减半，那么这就意味着同时需要思考的变量个数平均来讲是原来的一半。

对类成员访问进行约束的方法是“尽量使方法变成静态的”。静态方法是让读者知道“这几行代码与那些变量无关”的好办法。

或者还有一种方式是“把大的类拆分成小一些的类”。这种方法只有在这些小一些的类事实上相互独立时才能发挥作用。如果你只是创建两个类来互相访问对方的成员，那你什么目的也没达到。

把大文件拆分成小文件，或者把大函数拆分成小函数也是同样的道理。这么做的一个重要的动机就是数据（即变量）分离。

> 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。
>
> 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法，实例方法则无此限制。

### C++中 if 语句的作用域

![](00122.jpg)

在本段代码中，变量`info`虽然只在`if`语句中用到，但是它仍在全局作用域中，可以将`info`定义在`if`条件表达式中，避免定义全局变量。

![](00205.jpg)

### 在 JavaScript 中创建“私有”变量

`JavaScript`在`ES6`之前没有块级作用域，只有函数作用域和全局作用域，可以分离作用域的方式只有单纯地将变量定义在一个函数中，通过闭包访问。

![](00158.jpg)

匿名函数的最大作用就是和闭包相配合，用来隔离变量和收揽权限。

`ES6`之后`JavaScript`新增了块级作用域，使用`let`和`const`来声明变量。避免使用`var`来声明变量，因为`var`会涉及到变量提升，而且不使用声明变量的关键字来声明变量会默认该变量为全局变量。这些糟粕已经被`ES6`废除掉了。

### 在 Python 和 JavaScript 中没有嵌套的作用域

`Python`我不是很了解，但是`JavaScript`在`ES6`已经完善了这部分。所以本部分内容只是代表`ES5`以前的写法，毕竟还是可能会遇到“祖传代码”。

像`C++`和`Java`这样的语言有“语句块作用域”，定义在`if`、`for`、`try`或者类似结构中的变量被限制在这个语句块的嵌套作用域里。

```C++
if (...) {
    int x = 1;
}
x++; // 'x' is undefined.
```

但是在`JavaScript`和`Python`中，在语句块中定义的变量会“溢出”到整个函数。例如，请注意在下面这段完全正确的`Python`代码中对`example_value`的使用：

![](00217.jpg)

如果第一段`if`代码没有定义`example_value`，第二段`for`代码必定会报错。为了避免这种情况，可以将变量定义提前到使用该变量的所有语句块的头部。

![](00206.jpg)

根据之前的讲解，这个临时变量`example_value`完全符合不应该使用的情形，可以通过提前返回来完善这部分代码：

![](00226.jpg)

### 把定义向下移

原来的`C`语言要求把所有的变量定义放在函数或语句块的顶端。这个要求很反人类，因为对于有很多变量的函数，它强迫读者马上思考这些变量，即使是要到很久之后才会用到它们。

因为读者在读到后面之前没有必要知道有什么变量，所以变量应该定义在对该变量的使用之前。

```javascript
function forExample() {
    let a = xxx;
    a ...
    let b = xxx;
    b ...
}
```

## 只写一次的变量最好

“永久固定”的变量很容易思考，例如`C++`和`JavaScript`中的`const`，`java`中的`final`等等。

在很多的语言中，一些内置类型也是不可变的，常量看起来总是最简单的。**操作一个变量的地方越多，越难确定它的当前值**。

很多时候需要改进代码的结构来实现这个思想。

## 实现本文思想的例子

如果一个网页上有几个`input`输入框，`id`分别为`input1，2，3 ...`。目的是实现一个函数，接收一个字符串并将字符串放在第一个空的`input`字段（`value`为空）中。

下面是这段代码：

![](00249.jpg)

首先，`found`作为中间变量，可以通过提前返回来消除。`elem`多次以循环的方式被用到，但是该变量只是单纯的在累加而已。`i`作为循环的累加值，可以将`while`改为`for`来让`i`在自己该出现的地方定义。

![](00139.jpg)

这段代码就已经修改完毕，请注意`elem`是如何成为一个只写一次的变量的，它的生命周期只在循环内。用`true`来作为`for`循环的条件并不多见，但作为交换，我们可以在同一行里看到`i`的定义与修改。（传统的`while(true)`也是个合理的选择。）

## 总结

本章是关于程序中的变量是如何快速累积而变得难以跟踪的。你可以通过减少变量的数量和让它们尽量“轻量级”来让代码更有可读性。具体有：

- 减少变量，即那些妨碍的变量。我们给出了几个例子来演示如何通过立刻处理结果来消除“中间结果”变量。

- 减小每个变量的作用域，越小越好。把变量移到一个有最少代码可以看到它的地方。眼不见，心不烦。

- 只写一次的变量更好。那些只设置一次值的变量（或者`const`、`final`、常量）使得代码更容易理解。
