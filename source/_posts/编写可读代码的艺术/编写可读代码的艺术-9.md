---
title: 编写可读代码的艺术（九）
tags:
  - 职业修养
categories:
  - 读书笔记
  - 编写可读代码的艺术
date: 2020-01-21 14:59:24
visible:
---


# 抽取不相关的子问题

工程学有一条原则，就是把大问题拆分成小问题再把这些问题的解决方案放回一起。这条原则放到代码中就会让代码更加易读。

1. 看看某个函数或代码块，问问你自己：这段代码高层次的目标是什么？

2. 对于每一行代码，问一下：它是直接为了目标而工作吗？这段代码高层次的目标是什么呢？

3. 如果足够的行数在解决不相关的子问题，抽取代码到独立的函数中。

本章的重点在于抽取不相关的子问题，即该问题对主函数流程没有什么影响，丝毫不用关心为什么去调用它。

## 介绍性的例子：fingClosestLocation()

这个章节将介绍什么是所谓的**不相关的子问题**。

![](Jietu20200121-175137.jpg)

这段代码的高层次目标（最直接要实现的功能）是“找到距离给定点最近的位置”。不难能看出下面这段代码和整段代码的逻辑关系不大：

```javascript
for(...) {
    // ...
}
var dist = ...
```

这段代码是用来计算需要用来对比的距离变量。这就是一个**不相关**的子问题。没人关心它内部的计算过程，只需要得到最终的值从而实现高层次的目标。

下面将这部分代码封装成一个函数：

![](00183.jpg)

最终函数就变成了这样：

![](00225.jpg)

## 纯工具代码

在日常项目中，肯定会有一些操作需要在不同模块经常的用到。这些核心任务有些已经由编程语言内置的库来实现，而有些项目中需要经常使用到但标准库中没有，就需要自己去实现。

这些类似“基本工具”的代码就是**不相关子问题**的经典例子。在我看来，不相关子问题就是一段实现某种功能的代码，且这段代码有普适性，就像螺丝钉一样，造航母可以用，造汽车也可以用。这些螺丝钉和他们应用环境的高层次目标（航母，汽车）不相关，每个人都只关心怎么造航母，没人关心螺丝钉内部怎么实现，拿来直接拧上去就好了。

这些纯工具代码可以抽离到一个新函数中，久而久之，可以建立起一套适合项目的代码库。

## 其他多用途代码

当调试`JavaScript`代码时，程序员经常使用`alert()`来弹出消息框，把一些信息显示给他们看，这是`Web`版本的`printf()`调试。例如，下面函数调用会用`Ajax`把数据提交给服务器，然后显示从服务器返回的对象。

![](00309.jpg)

这段代码的高层次目标就是“对服务器做`Ajax`调用，然后处理响应结果”。但是里面`alert()`相关代码与高层次目标毫无关系，这样的代码就可以抽离出来。

![](00355.jpg)

### 意料之外的好处

在将一段代码封装为函数之后，改进这段代码就会变得很容易。这段代码就会自成一体，如果修改一小段独立的代码，添加功能、改进可读性、处理边界情况等都更容易。

## 创建大量通用代码

几乎每个大型项目里面都会有一个`util`库文件，里面存放着可在多个项目和模块中重用的代码。

这种代码厉害之处在于“它完全地从项目的其他部分中解耦出来”，开箱即用，容易开发，容易测试，容易理解。

例如`jQuery`中封装了大量操作`DOM`的方法，用的人不必关心它的源码中是如何实现的，只需要知道它是用来做什么的就可以。

从项目中拆分出的独立库越多越好，因为这样会使代码的其他部分会更小而且更容易思考。

这里面有着**自顶向下或者自底向上式编程**的思想，大部分编程都是两者的结合。

> 自顶向下编程是一种风格，先设计高层次模块和函数，然后根据支持它们的需要来实现低层次函数。
>
> 自底向上编程尝试首先预料和解决所有的子问题，然后用这些代码段来建立更高层次的组件。

## 项目专有的功能

理想情况下，抽离出的子问题应该对项目一无所知，有很大的通用性，是完全的**工具人**。但有时也并非如此，有些方法抽离出来可能并没有通用性，但是也要尽量的分离出子问题。

这种代码被抽离出来应该存放的位置也是一个问题，不过这个问题并不重要，位置可以随意摆放。更重要的是这个函数被完全抽离出来，让读者不必被内部实现分散精力。

## 简化已有接口

人人都爱提供整洁接口的库——那种参数少，不需要很多设置并且通常只需要花一点工夫就可以使用的库。它让你的代码看起来优雅：简单而又强大。

但如果你所用的接口并不整洁，你还是可以创建自己整洁的“包装”函数。

例如在浏览器中操作`cookie`，这是一个对象，里面是一组键值对。但是浏览器只提供了一个`document.cookie`接口，具体对`cookie`的增删改查都需要先获取在自己编写代码实现。

这时就可以自己封装一套用来处理`cookie`的函数：

```javascript
const cookie = document.cookie;

function getCookieValue(name) {
  let result = document.cookie.match(
    "(^|[^;]+)\\s*" + name + "\\s*=\\s*([^;]+)"
  );
  return result ? result.pop() : "";
} // 调用该函数可以按照属性来查看cookie

function getCookieValue(name) {
  const nameString = name + "=";
  const value = document.cookie.split(";").filter(item => {
    return item.includes(nameString);
  });
  if (value.length) {
    return value[0].substring(nameString.length, value[0].length);
  } else {
    return "";
  }
}
// 添加cookie
const addCookirValue = (name, value) => {
  return (document.cookie = `${name}=${value}`);
};

// 删除某个信息
const deleteCookirValue = name => {
  let result = document.cookie.match(
    "(^|[^;]+)\\s*" + name + "\\s*=\\s*([^;]+)"
  );
  return result ? (document.cookie = `${name}=`) : "no data match";
};

// 删除cookie

const delCookie = name => {
  let exp = new Date();
  exp.setTime(exp.getTime() - 1);
  const cval = getCookieValue(name);
  if (cval != null)
    return (document.cookie = `${name}=${cval};expires=${exp.toGMTString()}`);
};
```

“你永远都不要安于使用不理想的接口”。总是可以创建自己的包装函数来隐藏接口的粗陋细节，让它不再成为你的阻碍。

## 按需重塑接口

程序中很多代码在那里只是为了支持其他代码——例如，为函数设置输入或者对输出做后期处理。这些“粘附”代码常常和程序的实际逻辑没有任何关系。这种传统的代码是抽取到独立函数的最好机会。

假如有一段代码时要将用户信息放到`URL`中。因为是敏感信息，所以要加密。加密的过程就成为了“粘附”代码。

![](00320.jpg)

下面对这段代码中的实现加密的部分进行封装：

![](00177.jpg)

封装后的程序中“真正”逻辑的代码就很简单：

![](00348.jpg)

本章中改进代码目标只是“积极地发现和抽取不相关的子问题”，但是过于积极就会适得其反。

![](Jietu20200121-190003.jpg)

这样更加细化的拆分代码缺点是显而易见的，引入过多的小函数会让可读性变差，其次会让读者阅读代码时目光一直跳跃。

为代码增加一个函数存在一个小的（却有形的）可读性代价。在这种情况里，付出这种代价却什么也没有得到。如果你项目的其他部分也需要这些小函数，那么增加它们是有道理的。但是目前为止，还没有这个需要。

## 总结

对本章一个简单的总结就是“把一般代码和项目专有的代码分开”。其结果是，大部分代码都是一般代码。通过建立一大组库和辅助函数来解决一般问题，剩下的只是让你的程序与众不同的核心部分。

这个技巧有帮助的原因是它使程序员关注小而定义良好的问题，这些问题已经同项目的其他部分脱离。其结果是，对于这些子问题的解决方案倾向于更加完整和正确。你也可以在以后重用它们。
