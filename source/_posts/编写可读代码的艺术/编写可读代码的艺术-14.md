---
title: 全书内容的实践
tags:
  - 职业修养
categories:
  - 读书笔记
  - 编写可读代码的艺术
visible: hide
date: 2020-01-30 21:51:39
---


# 设计并改进“分钟/小时计数器”

我们需要跟踪在过去的一分钟和一个小时里`Web`服务器传输了多少字节。下面的图示说明了如何维护这些总和：

![](00265.jpg)

## 定义类接口

下面是第一个接口版本：

![](00305.jpg)

### 改进命名

首先观察这个类中的命名是否有改进的余地。

这里面有一个类名，三个方法名和两个参数名。根据之前的知识，`Count`这个方法名称是有问题的，因为它的意思不明确（既是动词又是名词）。可以使用`Add`来替代。`num_bytes`太有针对性，虽然是为了统计字节数，但是其他人可能会用这个类统计查询的次数。可以使用`count`来作为代替（简单，暗示“非负数”）。

### 改进注释

这个类中有三个注释，第一个很明显说了一句废话，第二个有一些歧义，没有表明时间的范围（现在所在时间的分钟还是过去的一分钟）。还需要加上一条类级别的注释。

![](250.jpg)

在改进注释的过程中，要把自己当成其他人，通过外部的视角来判断注释是否有可以改进的空间。

## 定义解决问题方案

为了解决问题，可以保存一个有时间戳“事件”的列表。之后根据需要从列表中筛选出来符合条件的事件。

![](00232.jpg)

![](00236.jpg)

### 这段代码易于理解吗

虽然可以解决问题，但是可读性太差了，主要体现在下面两点：

- `for`循环太大，一口吃不下。大多数读者在读这部分代码时会显著地慢下来（至少他们应该慢下来，如果他们要确定这里的确没有 bug 的话）。

- `MinuteCount()`和`HourCount()`几乎一模一样。如果他们可以共享重复代码就可能让这段代码少一些。这个细节非常重要，因为这些重复的代码相对更复杂。（让有难度的代码约束在一起更好些。）

### 改进易读性之后

为了将两个十分相似的方法中重合的部分抽离出来，需要引入一个新的方法来处理`60`和`3600`的不同。

![](255.jpg)

- `CountSince`参数的命名为一个表示绝对意思的单词，理解起来容易一点
- 将迭代器从`i`改为`rit`，因为是反向迭代器，通过加一个`r`来呼应`event.rend()`。
- 把条件`rit-＞time＜=cutoff`从`for`循环中抽取出来，并把它作为一条单独的``if`语句。为什么这么做？因为保持循环的“传统”格式f`or(begin;end;advance)`最容易读。读者会马上明白它是“遍历所有的元素”，并且不需要再做更多的思考。

### 性能问题

- 由于这个类一直保存着它见过的所有事件，这意味着它对内存的使用是没有限制的。需要在代码中操作来删除不需要的事件
- `MinuteCount()`和`HourCount()`太慢了，`CountSince()`这个方法的时间为`O(n)`，其中`n`是在其相关的时间窗口内数据点的个数。最好`MinuteHourCounter`能记住`minute_count`和`hour_count`变量，并随每次对`Add()`的调用而更新。

## 传送带设计改进代码

对于之前的两个问题，可以使用传送带设计方式来解决。

- 第一种是维护两个独立的`list`，一个用于过去一分钟的事件，一个用于过去一小时。当有新事件到达时，在两个列表中都增加一个拷贝。
- 另一种方法是维护两个`list`，事件先会进入第一个列表（“最后一分钟里的事件”），然后这个列表会把数据传送给第二个列表（“最后一小时[但不含最后一分钟]里的事件”）。

第二种显然比较好，因为少创建了一次事件拷贝。

### 实现第二种方法

首先定义类的成员：

![](256.jpg)

这个传送带设计的要点在于要能随时间的推移“切换”事件，使事件从`minute_events`移到`hour_events`，并且 m`inute_count`和`hour_count`相应地更新。要做到这一点，我们会创建一个叫做`ShiftOldEvents()`的辅助方法。当我们有了这个方法以后，这个类的剩余部分很容易实现：

![](00305.jpg)

最终代码如下：

![](00246.jpg)

### 传动带方法的不足

这个设计的可扩展性太差，如果要修改需求，需要改动大量的代码。其次这个类占用的内存很大，如果服务流量较高，就需要大量调用`Add()`方法，这会占用很大的内存。在一个产品开发环境中，最好不论`Add()`被调用得多频繁，`MinuteHourCounter`能用固定数量的内存。

## 时间桶设计方案

这里的关键思想是把一个小时间窗之内的事件装到桶里，然后用一个总和累加这些事件。例如，过去 1 分种里的事件可以插入 60 个离散的桶里，每个有 1 秒钟宽。过去 1 小时里的事件也可以插入 60 个离散的桶里，每个 1 分钟宽。

![](00250.jpg)

如果要更精确，可以使用更多的桶，以使用更多内存为交换。但重要的是这种设计使用固定的、可预知的内存。

### 实现时间桶设计

首先创建一个不同的类保存一个时间段里的计数：

![](00251.jpg)

传入当前时间（time_t now）有两个好处。首先，它让`TrailingBucketCounter`成为一个“时钟无关”的类，一般来讲这更容易测试而且会避免`bug`。其次，它把所有对`time()`的调用保持在`MinuteHourCounter`中。对于时间敏感的系统，如果能把所有获得时间的调用放在一个地方会有帮助。

我接下来创建一个叫做`ConveyorQueue`的数据结构，它的工作是处理其下的计数与总和。`TrailingBucketCounter`类可以关注根据过去了多少时间来移动`ConveyorQueue`。

![](258.jpg)

再最终实现`TrailingBucketCounter`类：

![](00258.jpg)

最终，代码将变成这个样子：

![](00252.jpg)

这段代码更容易读，也更灵活——如果我们想增加桶的数量（通过增加内存使用来改善精度），那将会很容易。

## 比较三种方案

![](00261.jpg)

请注意最后那个有三个类的方案的代码数量比任何其他的尝试都多。然而，性能好得多，并且设计更灵活。而且，每个类自己都更容易读。这是一个正面的改进：有 100 行易读的代码比有 50 行不易读的要好。

有时，把一个问题拆成多个类可能引入类之间的复杂度（在有单个类的方案中是不会有的）。然而，在本例中，有一个简单的“线性”链条连接着每个类，并且只有一个类暴露给了最终用户。总体来讲，拆分这个问题所得到的好处更大。

## 总结

让我们回顾得到最后的`MinuteHourCounter`设计所走过的路。这是个典型的代码片段演进过程。

首先，我们从编写一个幼稚的方案开始。这帮助我们意识到两个设计上的挑战：速度和内存使用情况。

接下来，我们尝试用“传送带”设计方案。这种设计改进了速度和内存使用情况，但对于高性能应用来讲还是不够好。并且，这个设计不是很灵活：让这段代码能处理其他的时间间隔需要很多工作。

我们最终的设计解决了前面的问题，通过把问题拆分成子问题。下面是创建的三个类，自下向上，以及每个类所解决的子问题：

- ConveyorQueue

    - 一个最大长度的队列，可以“移位”并且维护其总和。

- TrailingBucketCounter

    - 根据过去了多少时间来移动ConveyorQueue，并且按所给的精度来维护单一（最后）的时间间隔中的计数。

- MinuteHourCounter

    - 简单地包含两个`TrailingBucketCounters`，一个用来统计分钟，一个用来统计小时。

