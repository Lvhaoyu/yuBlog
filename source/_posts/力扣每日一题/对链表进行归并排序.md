---
title: 对链表进行归并排序
tags:
  - 基础算法
categories:
  - 算法
  - 每日一题
date: 2020-11-21 15:36:37
visible:
---


# 对链表进行归并排序

[题意](https://leetcode-cn.com/problems/sort-list/)是给你一个链表，按照升序返回一个新的链表。

要求是时间复杂度为`O(nlogn)`，空间复杂度为常数级别。

其实也只有归并排序可以符合题目的要求了。

## 数组的归并排序

归并排序是很难理解的一种排序算法，甚至会疑问，这样也能排序？它的核心思想就是先将数组切开，左边一半，右边一半，之后左右两个部分递归切分，当切到每个数组只有一个元素的时候。就可以认定它们每个数组已经排好序了，因为只要不动就可以了。之后就是将这些被切开的数组合并到一起，在合到一起的时候，进行比较。

### 归并排序的递归实现

归并排序就是递归 + 合并，所以大部分都用递归来实现。

```js
const merge = (left, right) => {
	if (left.length === 0) return right;
	if (right.length === 0) return left;
	return left[0] > right[0]
		? [right[0]].concat(merge(left, right.slice(1)))
		: [left[0]].concat(merge(left.slice(1), right));
};

const mergeSort = (arr) => {
	let len = arr.length;
	if (len === 1) {
		return arr;
	}
	let left = arr.slice(0, Math.floor(len / 2));
	let right = arr.slice(Math.floor(len / 2));
	return merge(mergeSort(left), mergeSort(right));
};
```

## 链表的归并排序

### 取巧的方法

当然，所有单向链表的排序题目都可以将链表打散成数组再排序，之后在组装成链表就可以。但是这样写代码并不好，代码如下：

```js
var sortList = function (head) {
	let res = [];
	if (!head) return null;
	while (head) {
		res.push(head);
		let tmp = head.next;
		head.next = null;
		head = tmp;
	}
	res.sort((a, b) => {
		return a.val - b.val;
	}).reduce((pre, cur) => {
		return (pre.next = cur);
	});
	return res[0];
};
```

### 常规写法

常规写法就是直接操作链表，代码如下：

```js
var sortList = function (head) {
	// 判断输入是否有效
	if (!head || !head.next) return head;
	// 利用快慢指针找到中点方便后续断开链表
	let slow = head,
		fast = head.next;
	while (fast && fast.next) {
		slow = slow.next;
		fast = fast.next.next;
	}
	// 将链表以中点断开
	let tmp = slow.next;
	slow.next = null;
	// 递归调用，将链表全部断开
	let left = sortList(head);
	let right = sortList(tmp);
	// 定义虚拟节点，方便后续操作
	let dummy = new ListNode(0);
	// 记录此刻虚拟节点的值，方便后续返回值
	let res = dummy;
	// 开始进行比较，使用 left 和 right 两个双指针，合并到链表头部
	while (left != null && right != null) {
		if (left.val < right.val) {
			dummy.next = left;
			left = left.next;
		} else {
			dummy.next = right;
			right = right.next;
		}
		// dummy 节点向后遍历
		dummy = dummy.next;
	}
	// 遍历之后，可能还剩下多余的节点，这里判断一下
	dummy.next = left ? left : right;
	return res.next;
};
```

## 总结

链表的归并排序和数组的归并排序没有什么区别，只要掌握好链表的操作方法，以不变应万变就可以了。