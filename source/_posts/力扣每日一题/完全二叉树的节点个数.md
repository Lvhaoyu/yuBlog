---
title: 完全二叉树的节点个数
tags:
  - 基础算法
categories:
  - 算法
  - 每日一题
date: 2020-11-24 23:12:17
visible:
---


# 完全二叉树的节点个数

[这道题目](https://leetcode-cn.com/problems/count-complete-tree-nodes/)的目的就是求一棵完全二叉树的总节点个数。

## 两种二叉树的定义

### 完全二叉树（complete）

一棵深度为 k 的有 n 个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为 i（1≤i≤n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。

### 完美二叉树（perfect）

除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。

## 完满二叉树（严格二叉树 full/strict）

所有非叶子节点的子节点都有两个。

## 解题思路

二叉树的节点可以通过深搜和广搜来实现，但是，如果这样实现，时间复杂度为`O(n)`。没有利用到完全二叉树这个条件，满二叉树的节点计算是有公式的，为`2^n - 1`。所以如果我们能利用这个条件，就可以直接用数学公式计算出半边子树的节点个数，再通过常规计算，计算出另外半边就可以了。

## 代码编写

下面给出传统的适用于所有二叉树的深搜和广搜的 JavaScript 代码：

```js
var countNodes = function (root) {
	if (!root) return 0;
	return countNodes(root.left) + countNodes(root.right) + 1;
};
```

```js
var countNodes = function (root) {
	if (!root) return 0;
	let q = [],
		count = 0;
	q.push(root);
	count++;
	while (q.length) {
		let qLen = q.length;
		for (let i = 0; i < qLen; i++) {
			let s = q.shift();
			if (s.left != null) {
				q.push(s.left);
				count++;
			}
			if (s.right != null) {
				q.push(s.right);
				count++;
			}
		}
	}
	return count;
};
```

下面就是利用题干的完全二叉树的定义写出的优化解法：

```js
var countNodes = function (root) {
	if (!root) return 0;
	let leftDepth = countLevel(root.left);
	let rightDepth = countLevel(root.right);
	if (leftDepth === rightDepth) {
		// 如果求 2 的 k 次方，使用 1 << k 的写法
		return countNodes(root.right) + (1 << leftDepth);
	} else {
		return countNodes(root.left) + (1 << rightDepth);
	}
};

function countLevel(root) {
	let count = 0;
	while (root) {
		count++;
		root = root.left;
	}
	return count;
}
```

## 总结

使用通用方法的时间复杂度是`O(n)`。使用改进方法的时间复杂度为求单边完美二叉树的层高`O(logn)`和计算单边子树的节点数量`O(logn)`，一共是`O(logn * logn)`。
