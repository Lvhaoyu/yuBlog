---
title: 用最少数量的箭引爆气球
tags:
  - 基础算法
categories:
  - 算法
  - 每日一题
date: 2020-11-23 13:12:20
visible:
---


# 用最少数量的箭引爆气球

[这道题目](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)说的是，有以排气球，排列在一个二维坐标系中，从 X 轴射箭将它们击破，气球的位置可能重叠，求将它们击破需要的箭的最小数量。

## 解题思路

一般遇到这种题，可以看出来本质是求重合的区间。做法就是先排序，之后遍历整个数组，求出有多少个不重合的区间。

## 代码编写

### 正序遍历

```js
/**
 * @param {number[][]} points
 * @return {number}
 */
var findMinArrowShots = function(points) {
    // 判断数组是否有效
    if (!points.length) return 0;
    // 对数组进行排序
    points.sort((a, b) => a[1] - b[1]);
    // 定义需要的箭数量
    let count = 1;
    // 因为是排序后的，定义初始值来判断重合区间
    let minExplosion = points[0][1];
    // 遍历数组，如果区间不重合，数量加一
    for (let i = 0; i < points.length; i++) {
        if (minExplosion < points[i][0]) {
            minExplosion = points[i][1]
            count++;
        }
    }
    return count;
};
```

### 反序遍历

上个方法是按照气球结束区间进行排序，也可以按照开始的区间进行排序，从后往前判断重合区间。

```js
/**
 * @param {number[][]} points
 * @return {number}
 */
var findMinArrowShots = function(points) {
    // 判断数组是否有效
    if (!points.length) return 0;
    // 对数组进行排序
    points.sort((a, b) => a[0] - b[0]);
    // 定义需要的箭数量
    let count = 1;
    // 因为是排序后的，定义初始值来判断重合区间
    let maxExplosion = points[points.length - 1][0];
    // 遍历数组，如果区间不重合，数量加一
    for (let i = points.length - 1; i >= 0; i--) {
        if (maxExplosion > points[i][1]) {
            maxExplosion = points[i][0]
            count++;
        }
    }
    return count;
};
```

## 总结

本题解法的时间复杂度为`O(nlogn)`，为排序的时间复杂度，遍历的`O(n)`可以忽略。空间复杂度为排序的空间复杂度`O(logn)`。


