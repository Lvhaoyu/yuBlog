---
title: 图解http第三章
tags:
  - web前端
  - 网络基础
categories:
  - 读书笔记
  - 图解HTTP
date: 2019-01-02 12:13:04
---


# HTTP 报文内的 HTTP 信息

用于`HTTP`协议交互的信息被称为`HTTP`报文。客户端发送请求报文给服务端，服务端发送响应报文给客户端。`HTTP`报文本是是由多行（使用 CR+CL 作为换行符）数据构成的字符串文本。

## HTTP 报文的结构

HTTP 报文结构如下：

![](00041.jpeg)

![](00042.jpeg)

> CRLF, LF 是用来表示文本换行的方式。CR(Carriage Return) 代表回车，对应字符 '\r'；LF(Line Feed) 代表换行，对应字符 '\n'。由于历史原因，不同的操作系统文本使用的换行符各不相同。主流的操作系统一般使用 CRLF 或者 LF 作为其文本的换行符。其中，Windows 系统使用的是 CRLF, Unix 系统(包括 Linux 使用的是 LF，MAC OS 使用的是 LF 表示下一行。

### 请求行

包含用于请求的方法，请求`URI`和`HTTP`版本。

> 只有字母和数字[0-9a-zA-Z]、一些特殊符号”\$-\_.+!\*’(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于 URL。

关于`URI`是采用`ASCII`码进行编码的，所以只能存在阿拉伯数字，英文字母和某些标点符号，当遇到汉字时，就需要采用`unicode + %`的形式进行编码，当遇到保留字时，需要采用`ASCII + %`进行编码。

### 状态行

包含表明响应结果的状态码，原因短语和`HTTP`版本。

### 首部字段

分为通用首部，请求首部，响应首部，实体首部四种，指明了请求和响应的各种条件和属性。

有些可能会存在`RFC`中不存在的首部（Cookie）。

- 通用首部字段（General Header Fields） 请求和响应报文两方都会使用的首部字段
- 请求首部字段（Reauest Header Fields）客户端向服务器发送请求的报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关的优先等级信息。
- 响应首部字段（Response Header Fields）从服务器向客户端响应时使用的字段，补充响应的附加内容，也会要求客户端附加额外信息
- 实体首部字段（Entiy Header Fields） 针对请求报文和响应报文的实体部分使用首部。补充了资源内容更新时间等实体有关的信息

### 关于编码规范的补充

在计算机中，存储数据的最小单位是**位**（`bit`），一个字节是八个二进制位，即一个字节就是`8`个比特，一个字节可以存一个`ASCII`码，两个字节可以存一个汉字国标码。

编码模型有两种，一种是简单字符集，也就是`ASCII`码，硬性规定每个字符如何对应计算机里面的比特，`HTTP`就是以`ASCII`码传输的。

第二种是现代编码模型：

- 首先确定系统需要支持哪些字符，确立字符表
- 之后给字符表中的字符整合到一个整数集合的映射，被称为**编码字符集**（Unicode 为这一层面）
- 将编码字符集中的整数转为有限长度的比特值，整合成**字符编码表**，之后计算机就可以使用一定长度的二进制表示该整数（utf-8，utf-16 属于该层）
- 计算机底层根据不通操作系统实现来存储

例如`JavaScript`使用的是`utf-16`编码方式，即**代码单元**（Code Unit）是以两个字节（16bit）作为最小单位，`Unicode`编码字符集的基本单位为**代码点**（Code Point），字符在该字符集的编号，然后通过对应的编码方式将代码点转换为对应的代码单元一一对应表示。

`utf-8`则是使用`1-3`个字节来表示代码点，可以兼容`ASCII`码，但是`utf-16`就不可以兼容了。

在`JavaScript`中，使用字符串的`.length`方法，就会有一些小坑，当`Unicode`范围在`U+000~U+FFFF`中，在`JavaScript`中表式一个字符长度（即两个字节存储），但是超出这个范围，就会使用四个字节来存储（判断为两个字符的长度），所以要注意自己判断的字符串中有没有是四个字节存储的字符，以免计算失误。

## 编码提升传输速率

`HTTP`在传输数据时可以按照数据原貌传输，也可以在传输过程中通过编码提升传输速率。通过在传输时编码，可以有效处理大量的访问请求，但是也意味着要耗费更多的`CPU`资源。

### 报文主体与实体主体的差距

#### 报文

报文是简单的格式化数据块，是`HTTP`通信中的基本单位，由**8 位组字节流**组成，通过`HTTP`通信传输。

> 八位组字节流：英文`octet sequence`，`Octet`是计算机中提及 8 位数据的术语， `Byte`是在计算机中提及编码字符串字符所需的位数的术语，因为某些计算机可能一字节是 16 位，使用`Octet`比较明确，我认为这里理解成“八位的字节组成的序列”稍好一点。

#### 实体

作为请求或响应的**有效载荷数据**（补充项）被传输，其内容由实体首部和实体主体组成。

有效载荷数据：

> 负载（Payload）是数据传输中所欲传输的实际信息，通常也被称作实际数据或者数据体。信头与元数据，或称为开销数据，仅用于辅助数据传输。
> 头（header）指的是在一块数据存储或传输之际在头追加的数据，这些信息是对数据区的描述。
> 元数据（metadata）又称诠释数据、中介数据、中继数据、后设数据等，为描述其他数据信息的数据。

首先，报文只有请求和响应报文之分，就是一次通信的基本单位，报文中分为报文首部，空行，报文主体（报文主体包含实体），但是报文主体可以没有，报文主体不存在，实体自然也不存在。

一般情况下报文主体等于实体主体，那什么情况下不等于呢？就是传输中进行了编码操作，实体中还有一个实体首部和实体主体的概念，实体首部放在报文首部，实体首部加上实体主体，就是实体。

```
HTTP/1.1 200 OK
Content-Type: xxx
Transfer-Encoding: chunked

25
This is the data in the first chunk

1C
and this is the second one

3
con

8
sequence

0


```

以上简单描绘了一个分块传输编码的响应报文，上边提到过实体是**有效载荷数据**，所以实体在这个报文中就是里面的英文单词，其余的换行啊，块大小标识都不算实体，只有真正承载信息的才算。

### 压缩传输的内容编码

压缩文件就像是在电脑中为了文件变小可以使用`zip`压缩，`HTTP`中也有对应的内容编码功能来实现相似的操作。

内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩，由客户端收到进行解码。

`Accept-Encoding`和`Content-Encoding`是`HTTP`中用来*采用何种编码格式传输正文*进行协定的一对头部字段。它的工作原理是这样：浏览器发送请求时，通过`Accept-Encoding`带上自己支持的内容编码格式列表；服务端从中挑选一种用来对正文进行编码，并通过`Content-Encoding`响应头指明选定的格式；浏览器拿到响应正文后，依据`Content-Encoding`进行解压。当然，服务端也可以返回未压缩的正文，但这种情况不允许返回`Content-Encoding`。这个过程就是`HTTP`的内容编码机制。

常见的压缩方式：

- compress - UNIX 的“compress”程序的方法（历史性，不推荐大多数应用使用，应该使用 gzip 或 deflate）
- deflate – 基于 deflate 算法（定义于 RFC 1951）的压缩，使用 zlib 数据格式（RFC 1950）封装
- exi – W3C 高效 XML 交换
- gzip – GNU zip 格式（定义于 RFC 1952）。此方法截至 2011 年 3 月，是应用程序支持最广泛的方法
- identity – 不转换内容。这是内容编码的默认值
- pack200-gzip – 传输 Java 存档文件的网络传输格式

### 分割发送的分块传输编码

在`HTTP`通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。

这里对应的就是[上文](#实体)实体的说明，是完全对实体的操作，对实体进行拆解并组装。

![](Jietu20200106-181104.jpg)

在`HTTP/1.1`之前没有`Transfer-Encoding: chunked`，要进行分块传输需要`Content-Length`来标识，现在只需要在响应头添加这个属性，就可以进行分块传输。`HTTP`服务器有时使用压缩（gzip）以缩短传输花费的时间。分块传输编码可以用来分隔压缩对象的多个部分。在这种情况下，块不是分别压缩的，而是整个负载进行压缩，压缩的输出再进行分块传输。在压缩的情形中，分块编码有利于一边进行压缩一边发送数据，而不是先完成压缩过程以得知压缩后数据的大小。

## 发送多种数据的多部分对象集合

`HTTP`支持多部分对象集合（Multipart）的方法，可以传输多种类型的实体，例如图片，文件等。

> Multipart：发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以 ASCII 码字符串编码的方式指明，就是利用 MIME 来描述标记数据类型。而在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。

### multipart/form-data

在`WEB`表单上传时使用，这个请求貌似并没有在前一篇文章中`HTTP`支持的方法中实现，可见这个请求必然是之前方法的扩展。

该请求是基于`POST`请求，但是区别在于请求头和请求体。

```
Content-Type: multipart/form-data; boundary=AaB03x
　
--AaB03x
Content-Disposition: form-data; name="field1"
　
Joe Blow
--AaB03x

Content-Disposition: form-data; name="pics"; filename="file1.txt"
Content-Type: text/plain
　
...（file1.txt的数据）...
--AaB03x--
```

可见请求头部多了一个`boundary=xxx`，这个`xxx`是分隔符，自己随意写，但为了避免和正常的文本重复，尽量复杂。请求体增加了分隔符，参数描述信息等内容。每个部分都有对参数信息的详细描述，可见为什么可以传更复杂的文件了。

其实按照`POST`的形式来看，每个分隔符之中的内容，就像是正常上传表单信息的键值对，只是更加详细了而已。

### multipart/byteranges

状态码 206（Partial Content，部分内容）响应报文包含了多个范围的内容时使用。

```
HTTP/1.1 206 Partial Content
Date: Fri, 13 Jul 2012 02:45:26 GMT
Last-Modified: Fri, 31 Aug 2007 02:02:20 GMT
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES


--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 500-999/8000


...（范围指定的数据）...
--THIS_STRING_SEPARATES
Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000


...（范围指定的数据）...
--THIS_STRING_SEPARATES--
```

可见与前者的格式上并无差别，二者在结束部分都以`--xx--`作为结束符，中间以`--xx`来进行分隔。

## 获取部分内容的范围请求

当网速有局限性，需要采用范围请求的技术，来实现断点续传的功能。

例如有一份`10000`字节的资源，使用范围请求，客户端请求报文字段如下：

```
Range: bytes=5001-10000         // 5001~10 000 字节
Range: bytes=5001-              // 从 5001 字节之后全部的
Range: bytes=-3000, 5000-7000   // 从一开始到 3000 字节和 5000~7000 字节的多重范围
```

服务端响应报文如下：

```
Content-Range: bytes 5001-10000
Content-Length: 5000
```

针对范围请求，响应会返回状态码为`206 Partial Content`的响应报文。另外，对于多重范围的范围请求，响应会在首部字段`Content-Type`标明`multipart/byteranges`后返回响应报文。
如果服务器端无法响应范围请求，则会返回状态码`200 OK`和完整的实体内容。

## 内容协商返回最合适的内容

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。

内容协商请求报文相关首部字段如下：

```
GET /portal/edu_news/teachers?id=21052 HTTP/1.1
Host: www.jszg.edu.cn
Accept: text/html;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 // 客户端或者代理能够处理的媒体类型
Accept-Encoding: gzip, deflate              // 客户端优先可处理的编码格式
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8    // 客户端优先可处理的自然语言，0-1，值越大，优先级越高，可以近似匹配
Accept-Charset: xxx                         // 优先可以处理的字符集
```

内容协商响应报文相关首部字段如下：

```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8
Transfer-Encoding: chunked
Content-Language: zh-CN                    // 实体的资源语言
Content-Encoding: gzip                     // 实体的编码格式

<?xml version="1.0" encoding="UTF-8" ?>
```

### 内容协商技术类型

内容协商技术有以下 3 种类型。

#### 服务器驱动协商（Server-driven Negotiation）

由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。

#### 客户端驱动协商（Agent-driven Negotiation）

由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用`JavaScript`脚本在`Web`页面上自动进行上述选择。比如按`OS`的类型或浏览器类型，自行切换成`PC`版页面或手机版页面。

就是给用户弹出一个选项框，让用户自己选，也就意味着客户端需要请求两次。

#### 透明协商（Transparent Negotiation）

是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

该方法是通过某个中间设备（缓存代理）代替客户端进行协商，代理了解客户端的预期，发送对应首部的最佳匹配，节省了请求开销，但是没有相关的规范。
