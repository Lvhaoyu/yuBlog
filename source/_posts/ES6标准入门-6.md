---
title: ES6标准入门-6
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
date: 2020-02-24 22:54:17
visible:
---


# 函数的扩展

## 函数参数的默认值

`ES6`允许为参数设置默认值，具体使用就是将默认值直接写在参数的后面，当参数为`undefined`时，使用默认值。

```js
function log(x, y = 'World') {
  console.log(x, y);
}

log('Hello'); // Hello World
log('Hello', 'China'); // Hello China
log('Hello', ''); // Hello
```

阅读代码的人可以直观的看到哪些参数可以省略，而且以后代码优化时，就算参数没传，函数也能正常运行。

函数参数中的变量为默认声明的，不能在函数体中再次声明。且使用函数参数默认值时，函数中不能有同名参数。

```js
function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}

// 报错
function foo(x, x, y = 1) {
  // ...
}
// SyntaxError: Duplicate parameter name not allowed in this context
```

函数参数默认值是惰性求值，每次都是重新计算赋值。

```js
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo(); // 100

x = 100;
foo(); // 101
```

可见每次调用`foo`，都会重新计算`x + 1`。

## 与解构赋值默认值结合使用

```js
function foo({ x, y = 5 }) {
  console.log(x, y);
}

foo({}); // undefined 5
foo({ x: 1 }); // 1 5
foo({ x: 1, y: 2 }); // 1 2
foo(); // TypeError: Cannot read property 'x' of undefined
```

这个是函数参数的解构赋值，没有使用函数的默认值。

```js
function foo({ x, y = 5 } = {}) {
  console.log(x, y);
}

foo(); // undefined 5
```

这个则是函数的默认值配合解构赋值，如果没有参数，则默认传一个空对象。

如果函数的参数是对象，且对对象中的参数进行了解构赋值，这时参数不可以省略。但是如果给函数参数默认值，且又对函数参数进行了解构赋值，这时函数的参数可以省略，代码也不会报错。

```js
function f(x, y = 5, z) {
  return [x, y, z];
}

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
```

如果函数的默认值放到了非尾参数上，则该参数无法省略。

```js
(function(a) {}
  .length(
    // 1
    function(a = 5) {}
  )
  .length(
    // 0
    function(a, b, c = 5) {}
  ).length); // 2
```

指定了默认值后，函数的`length`属性将失真，有默认值的参数不计入`length`属性。

```js
(function(a = 0, b, c) {}.length(
  // 0
  function(a, b = 1, c) {}
).length); // 1
```

如果设置了默认值的参数不是尾参数，`length`属性也不会计入后面的参数了。

设置参数默认值后，函数进行声明初始化时，参数会形成一个单独的作用域。即相当于在块作用域内使用`let`声明的行为。且与函数内部的作用域互相独立，取值取决于外层作用域有没有对应的变量。

根据函数参数默认值的特性，可以指定某一个参数不能省略，如果省略就抛出一个错误。

```js
function throwIfMissing() {
  throw new Error('Missing parameter');
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo();
// Error: Missing parameter
```

如果未传参数则调用默认值中的函数，抛出一个错误。相反的，如果想表明函数的参数可以 省略，可以将参数的默认值设为`undefined`，表明参数可以省略。

## rest 参数

`ES6`引入了`rest`参数（`...变量名`），用来取代`argusments`类数组对象。`rest`参数中的变量名是一个数组，将多余的参数放到该变量名表示的一个数组中。

```js
function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3); // 10
```

`argusments`是一个类数组对象，但是`rest`是一个真正的数组，且`rest`只能作为最后一个参数。函数的`length`属性也不包括`rest`。

## 严格模式

在`ES5`的时候，严格模式`use strict`可以写在文件首部或函数体内部首部。`ES6`则规定，如果函数参数使用了解构赋值，默认值，扩展运算符，函数内部就不能显式的设置为严格模式。其实在`ES6`中，类和模块之中默认开启了严格模式，绝大部分代码都是在模块中开发的，这种情况也很少见。

上述设置的原因是因为函数参数中的语句先执行，但是限制在函数体中，只有执行到了函数体才能知道设置没设置严格模式。这样就会造成某些预期外的错误。

两种方法可以避免该限制，第一种是在全局设定严格模式，第二种就是使用无参数立即执行函数，将函数包裹在里面返回。

```js
const doSomething = (function() {
  'use strict';
  return function(value = 42) {
    return value;
  };
})();
```

## name 属性

函数的`name`属性返回函数的函数名，如果将一个匿名函数给一个变量，`ES5`的`name`属性返回空字符串，`ES6`的`name`属性返回实际的函数名。

```js
var f = function() {};

// ES5
f.name; // ""

// ES6
f.name; // "f"
```

如果是函数声明的函数赋值给一个变量，`ES5`和`ES6`的`name`属性都返回这个具名函数原本的名字。

```js
const bar = function baz() {};

// ES5
bar.name; // "baz"

// ES6
bar.name; // "baz"
```

`Function`构造函数返回的函数实例，`name`属性的值为`anonymous`（匿名）。`bind`返回的函数，`name`属性会加上`bound`前缀。

```js
new Function().name; // "anonymous"

function foo() {}
foo
  .bind({})
  .name(
    // "bound foo"

    function() {}
  )
  .bind({}).name; // "bound "
```

## 箭头函数

`ES6`中允许使用`=>`来定义函数。

### 基本概念

箭头左侧为参数，右侧为返回值；如果返回值只有一个，可以不加大括号和`return`；如果不需要参数或参数有多个，使用一个圆括号代表参数部分，如果只需要一个参数，括号可以省略；返回值使用括号包括大括号可以直接返回一个对象，原因是解析器会将大括号解析为代码块，所以要加括号。

```js
var f = () => 5;
// 等同于
var f = function() {
  return 5;
};

var sum = (num1, num2) => num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};

let getTempItem = id => ({ id: id, name: 'Temp' });
```

如果代码块有多行语句，需要用大括号包括，将返回值`return`。

```js
var sum = (num1, num2) => {
  return num1 + num2;
};
```

如果箭头函数只有一行且不用写返回值，可以使用`void`运算符：

```js
let fn = () => void doesNotReturn();
```

箭头函数也可以和解构赋值配合使用：

```js
const full = ({ first, last }) => first + ' ' + last;

// 等同于
function full(person) {
  return person.first + ' ' + person.last;
}
```

箭头函数的一个用处就是简化回调函数：

```js
// 正常函数写法
var result = values.sort(function(a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) => a - b);
```

箭头函数配合`rest`使用：

```js
const numbers = (...nums) => nums;
```

### 箭头函数使用注意部分

#### 函数体内的 this 对象，为定义时所在的对象，不是使用时所在的对象

在传统函数中，`this`是执行时确定的，也就是可变的，但是在箭头函数中，它是固定的。

```js
function foo() {
  setTimeout(() => {
    console.log('id:', this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
// id: 42
```

`setTimeout`中的回调函数执行在`100ms`之后，等到它开始执行，外层`foo`已经执行完毕，此时它的`this`应该是`window`，但是箭头函数的`this`永远指向函数定义生效时所在的对象，所以输出是`42`。

箭头函数让`this`固化的性质很有利于封装回调函数。

```js
var handler = {
  id: '123456',

  init: function() {
    document.addEventListener(
      'click',
      event => this.doSomething(event.type),
      false
    );
  },

  doSomething: function(type) {
    console.log('Handling ' + type + ' for ' + this.id);
  }
};
```

因为箭头函数的`this`指向固定为`handler`对象，所以`init`可以正常运行，否则由于`addEventListener`绑在`document`上，运行时`this`会指向`document`。这里面有一个知识点，就是事件绑定的函数（非箭头函数）`this`在运行时确定，会指向当前绑定事件的元素。

![](111.jpg)

![](222.jpg)

之所以说箭头函数的`this`在定义时确定，是因为它就没有`this`这个东西，对外显示的是`this`永远等于外层代码块的`this`，因此也不能用作构造函数。

既然没有`this`，所以传统函数中指向外层函数的对应变量也不存在，也不能使用`call`，`apply`，`bind`这些方法去改变函数的指向。

同时箭头函数内部也不存在`arguments`，`super`，`new target`。

```js
function foo() {
  setTimeout(() => {
    console.log('args:', arguments);
  }, 100);
}

foo(2, 4, 6, 8);
// args: [2, 4, 6, 8]
```

#### 其他需要注意的部分

- 不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。
- 不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用`rest`参数代替。
- 不可以使用`yield`命令，因此箭头函数不能用作`Generator`函数

### 不适用场合

箭头函数使`this`由“动态”变为了“静态”，有两个场合不适用于箭头函数：

#### 定义方法内部含 this 的对象方法

```js
const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
};
```

如果`jumps`是一个普通函数，`this`指向于`cat`。如果写成箭头函数，本身没有`this`，指向于外层对象（这里是全局对象），因为对象不构成单独的作用域，导致箭头函数定义时的作用域是全局作用域。

#### 需要动态 this 的时候

```js
var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
});
```

上面代码运行时，点击按钮会报错，因为`button`的监听函数是一个箭头函数，导致里面的`this`就是全局对象。如果改成普通函数，`this`就会动态指向被点击的按钮对象。

#### 可读性需求

如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。

### 嵌套的箭头函数

箭头函数的内部还可以继续使用箭头函数：

```js
function insert(value) {
  return {
    into: function(array) {
      return {
        after: function(afterValue) {
          array.splice(array.indexOf(afterValue) + 1, 0, value);
          return array;
        }
      };
    }
  };
}

insert(2)
  .into([1, 3])
  .after(1); //[1, 2, 3]
```

转换成`ES6`：

```js
let insert = value => ({
  into: array => ({
    after: afterValue => {
      array.splice(array.indexOf(afterValue) + 1, 0, value);
      return array;
    }
  })
});

insert(2)
  .into([1, 3])
  .after(1); //[1, 2, 3]
```

## 尾调用优化

### 尾调用概念

尾调用（Tail Call）是函数式编程一个重要的概念，就是指某个函数的最后一步是调用另一个函数。

```js
function f(x) {
  return g(x);
}
```

尾调用只要是最后一步操作就可以，比如下面的`m`和`n`都是尾调用。

```js
function f(x) {
  if (x > 0) {
    return m(x);
  }
  return n(x);
}
```

### 尾调用优化

尾调用特殊之处在于它特殊的调用位置，函数调用是使用栈来进行，每次调用都会执行`进栈 => 运行结束 => 出栈`，直到全部出栈，执行后进先出原则，如果再调用某个函数中还有其他函数，则将其他函数进栈，其他函数执行结束，某个函数才会执行结束出栈。

尾调用由于是函数最后一步操作，不需要保留外层函数的调用帧，直接把外层函数的调用帧（结果）取代就可以了。

```js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```

这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。

注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。

```js
function addOne(a) {
  var one = 1;
  function inner(b) {
    return b + one;
  }
  return inner(a);
}
```

这个是浏览器内部实现的，我们只要写出尾调用，引擎会自动根据情况优化。

## 尾递归

函数调用自己被称为递归，这属于算法范畴，如果函数尾调用自己，就是尾递归。递归很耗内存，一定要设置好终止条件，否则就会溢栈。但是如果是尾递归，那么由于存在优化，不与之前的调用帧关联，也就不存在溢栈的情况。

```js
function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5); // 120

function Fibonacci(n) {
  if (n <= 1) {
    return 1;
  }

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10); // 89
Fibonacci(100); // 超时
Fibonacci(500); // 超时
```

```js
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1); // 120

function Fibonacci2(n, ac1 = 1, ac2 = 1) {
  if (n <= 1) {
    return ac2;
  }

  return Fibonacci2(n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100); // 573147844013817200000
Fibonacci2(1000); // 7.0330367711422765e+208
Fibonacci2(10000); // Infinity
```

以上是递归和尾递归的区别，尾递归时间复杂度是$O(1)$，常规递归时间复杂度是$O(n)$。

### 递归函数的改写

如何将递归函数改写为尾递归呢？核心就是确保最后一步只调用自身，那么就需要将所有用到的内部变量改写为函数的参数。有两个直观的方法可以实现：

1. 在尾递归函数之外，再提供一个正常形式的函数

```js
function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

function factorial(n) {
  return tailFactorial(n, 1);
}

factorial(5); // 120
```

2. 函数柯里化

柯里化（currying）意思就是将多参数的函数转为单参数的形式。只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

```js
var add = function(x) {
  return function(y) {
    return x + y;
  };
};

var increment = add(1);
var addTen = add(10);

increment(2);
add(1)(2);
// 3

addTen(2);
// 12
```

这里我们定义了一个`add`函数，它接受一个参数并返回一个新的函数。调用`add`之后，返回的函数就通过闭包的方式记住了`add`的第一个参数。

```js
function currying(fn, n) {
  return function(m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5); // 120
```

3. 采用 ES6 的函数默认值。

```js
function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5); // 120
```

### 总结

递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。

### 严格模式

`ES6`的尾调用优化只在严格模式下开启，正常模式下是无效的。因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈：

- func.arguments：返回调用时函数的参数。
- func.caller：返回调用当前函数的那个函数。

尾调用优化必然会移除这两个变量的信息，这两个变量也不再有用。万一有人使用尾递归时再调用这两个变量就会出错，所以只能在严格模式下开启尾递归调用优化，严格模式会默认禁止这两个变量。

### 自己实现尾递归调用优化

```js
unction tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco(function(x, y) {
  if (y > 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});

sum(1, 100000)
// 100001
```

上面代码中，`tco`函数是尾递归优化的实现，它的奥妙就在于状态变量`active`。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归`sum`返回的都是`undefined`，所以就避免了递归执行；而`accumulated`数组存放每一轮`sum`执行的参数，总是有值的，这就保证了`accumulator`函数内部的`while`循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。

## 函数参数的尾逗号

`ES2017`允许函数的最后一个参数有尾逗号，此前不允许。这样和对象的尾逗号一致，避免冗余。

## Function.prototype.toString()

该方法返回函数代码本身，以前会省略注释和空格。

```js
function /* foo comment */ foo() {}

foo.toString();
// function foo() {}
```

修改后的代码返回一模一样的原始代码：

```js
function /* foo comment */ foo() {}

foo.toString();
// "function /* foo comment */ foo () {}"
```

## catch 命令的参数省略

以前要求`catch`命令后必须跟参数，接收`try`代码块抛出的错误对象：

```js
try {
  // ...
} catch (err) {
  // 处理错误
}
```

`ES2019`允许`catch`语句省略参数：

```js
try {
  // ...
} catch {
  // ...
}
```
