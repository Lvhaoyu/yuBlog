---
title: ES6标准入门-9
date: 2020-02-29 16:06:20
tags:
  - web前端
  - JS基础
categories:
  - 读书笔记
  - ES6标准入门
visible:
---

[toc]

# Symbol

## Symbol 背景

`ES5`的对象名称都是字符串，这就很容易造成属性名的冲突，如果别人使用或继承另一个人创造的对象，又想给这个对象增加方法，就可能会造成冲突。虽然可以再起一个不一样的名字，但是不能从根本杜绝这种问题。

## Symbol 的概念

`Symbol`是`ES6`新增的基本数据类型。一句话描述，这个数据类型提供一个独一无二的值，如果使用传统的基本类型来声明，会出现`let a = 5, let b = 5`，`a`和`b`是相等的情况。但是使用`Symbol()`来声明，就不会出现这种情况：

```js
let a = Symbol();
let b = Symbol();
a === b; // false
```

不可以使用`new`命令来声明，因为`Symbol`是原始类型的值，类似字符串，只能使用类似函数调用的方式声明。

`Symbol`可以接收一个字符串作为参数，表示对`Symbol`实例的描述，主要是为了在控制台显示的清楚一点，要不你是`Symbol()`，我也是`Symbol()`，虽然长得一样，但是不好判断。

```js
let s1 = Symbol('foo');
let s2 = Symbol('bar');

s1; // Symbol(foo)
s2; // Symbol(bar)

s1.toString(); // "Symbol(foo)"
s2.toString(); // "Symbol(bar)"
```

`Symbol`函数的参数如果接收到一个对象，就会调用对象的`toString()`方法转为字符串作为描述。相同参数的`Symbol`也不相等。

`Symbol`不能和其他类型的值做运算（会报错），只能显式的转为字符串和布尔值，不能转为数值。

```js
let sym = Symbol('My symbol');

String(sym); // 'Symbol(My symbol)'
sym.toString(); // 'Symbol(My symbol)'
```

![](111.jpg)

### Symbol.prototype.description

创建`Symbol`的时候可以添加一个描述，在之前读取描述只能将`Symbol`转为字符串。所以`ES2019`对应新增加了一个方法，用来读取`Symbol`的描述。

```js
const sym = Symbol('foo');
sym.description; // "foo"
```

### Symbol.for()

有时会有这样一个需求，之前新建了一个`Symbol`的值，但是我希望重新使用同一个`Symbol`的值。这时就需要`Symbol.for`来生成一个`Symbol`值。

它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的`Symbol`值。如果有，就返回这个`Symbol`值，否则就新建一个以该字符串为名称的`Symbol`值，并将其注册到全局。

```js
let s1 = Symbol.for('foo');
let s2 = Symbol.for('foo');

s1 === s2; // true
```

该方法接受一个字符串参数，如果没传，就会默认的传一个`undefined`。

![](222.jpg)

使用该方法生成的`Symbol`值无论在哪里生成，都会注册到全局环境，在生成之前会检索，如果有同`key`值得值已经声明，则会返回那个已经声明的值。但是`Symbol()`不会。

```js
Symbol.for('bar') === Symbol.for('bar');
// true

Symbol('bar') === Symbol('bar');
// false
```

### Symbol.keyFor()

该方法返回一个已登记的`Symbol`类型的`key`值：

```js
let s1 = Symbol.for('foo');
Symbol.keyFor(s1); // "foo"

let s2 = Symbol('foo');
Symbol.keyFor(s2); // undefined
```

只有使用`Symbol.for`登记过的`key`值才能被该方法返回。

## 作为属性名的 Symbol

使用`Symbol`作为对象的属性名，可以保证不会出现同名的属性。但是只能使用`[]`表达式的方式或调用某些方法来写入：

```js
let mySymbol = Symbol();

// 第一种写法
let a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
let a = {
  [mySymbol]: 'Hello!'
};

// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol]; // "Hello!"
```

不能使用点`.`来访问，否则编译器会认为点后面是一个字符串。`Symbol`作为属性名时，该属性还是公开属性，不是私有属性。

## Symbol 的遍历

使用`Symbol`作为属性名的对象，不能通过`for...of...`，`for...in...`的遍历方法遍历。（`for...in...`遍历的是键名，`for...of...`遍历的是部署原生的`iterator`接口对象的键值）。

但是可以通过`Object.getOwnPropertySymbols()`获得当前对象所有`Symbol`属性名并返回一个数组。

```js
const obj = {};
let a = Symbol('a');
let b = Symbol('b');

obj[a] = 'Hello';
obj[b] = 'World';

const objectSymbols = Object.getOwnPropertySymbols(obj);

objectSymbols;
// [Symbol(a), Symbol(b)]
```

`Reflect.ownKeys()`方法可以返回所有类型的键名，包括常规键名和 `Symbol`键名。

```js
let obj = {
  [Symbol('my_key')]: 1,
  enum: 2,
  nonEnum: 3
};

Reflect.ownKeys(obj);
//  ["enum", "nonEnum", Symbol(my_key)]
```

> Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。Reflect 不是一个函数对象，因此它是不可构造的。就是内置的一个对象，上面绑定了许多方法，和 Math，正则一样。

## 应用

### 单例模式

模块的单例模式指的是调用一个类，任何时候返回的都是同一个实例。

对于`Node`来说，模块就是一个类，要保证每次执行这个模块文件都返回同一个实例，可以把实例对象放到顶层`global`。

但是这样全局变量就可能会被无意间修改，这时可以使用`Symbol`。

```js
// mod.js
const FOO_KEY = Symbol.for('foo');

function A() {
  this.foo = 'hello';
}

if (!global[FOO_KEY]) {
  global[FOO_KEY] = new A();
}

module.exports = global[FOO_KEY];
```

但是还可以被改写：

```js
global[Symbol.for('foo')] = { foo: 'world' };

const a = require('./mod.js');
```

最终可以使用`Symbol()`的形式进行声明，这样别人无法引用，也改不了。但是多次执行同一个脚本每次生成的值都不一样。但是这种概率不大， 一是`node`有缓存，二是用户也可以手动清除缓存。

### 消除魔术字符串

在编程中，最忌讳的就是在代码中多次出现，与代码形成强耦合的某个具体的字符串或者数值，这样的代码不易读，也不容易找出错误。

消除魔术字符串的方法之一就是把魔术字符串改成一个常量。在某些情况下，例如`switch`语句，可能常量代表的值不重要，只是为了突出该属性不与其他属性的值冲突，就可以使用`Symbol`值。
